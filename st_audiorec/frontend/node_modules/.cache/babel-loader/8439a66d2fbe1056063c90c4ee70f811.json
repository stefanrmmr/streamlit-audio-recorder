{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _regeneratorRuntime from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _awaitAsyncGenerator from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(_fromIterable);\n\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer';\n/** @ignore */\n\nexport default {\n  fromIterable: function fromIterable(source) {\n    return pump(_fromIterable(source));\n  },\n  fromAsyncIterable: function fromAsyncIterable(source) {\n    return pump(_fromAsyncIterable2(source));\n  },\n  fromDOMStream: function fromDOMStream(source) {\n    return pump(_fromDOMStream2(source));\n  },\n  fromNodeStream: function fromNodeStream(stream) {\n    return pump(_fromNodeStream2(stream));\n  },\n  // @ts-ignore\n  toDOMStream: function toDOMStream(source, options) {\n    throw new Error(\"\\\"toDOMStream\\\" not available in this environment\");\n  },\n  // @ts-ignore\n  toNodeStream: function toNodeStream(source, options) {\n    throw new Error(\"\\\"toNodeStream\\\" not available in this environment\");\n  }\n};\n/** @ignore */\n\nvar pump = function pump(iterator) {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\n\n\nfunction _fromIterable(source) {\n  var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield$, it, _ref, _yield$byteRange;\n\n  return _regeneratorRuntime.wrap(function _fromIterable$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          byteRange = function _byteRange() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n\n            var _joinUint8Arrays = joinUint8Arrays(buffers, size);\n\n            var _joinUint8Arrays2 = _slicedToArray(_joinUint8Arrays, 3);\n\n            buffer = _joinUint8Arrays2[0];\n            buffers = _joinUint8Arrays2[1];\n            bufferLength = _joinUint8Arrays2[2];\n            return buffer;\n          };\n\n          threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context.next = 6;\n          return null;\n\n        case 6:\n          _yield$ = _context.sent;\n          cmd = _yield$.cmd;\n          size = _yield$.size;\n          // initialize the iterator\n          it = toUint8ArrayIterator(source)[Symbol.iterator]();\n          _context.prev = 10;\n\n        case 11:\n          // read the next value\n          _ref = isNaN(size - bufferLength) ? it.next(undefined) : it.next(size - bufferLength);\n          done = _ref.done;\n          buffer = _ref.value;\n\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n          if (!(done || size <= bufferLength)) {\n            _context.next = 22;\n            break;\n          }\n\n        case 16:\n          _context.next = 18;\n          return byteRange();\n\n        case 18:\n          _yield$byteRange = _context.sent;\n          cmd = _yield$byteRange.cmd;\n          size = _yield$byteRange.size;\n\n        case 21:\n          if (size < bufferLength) {\n            _context.next = 16;\n            break;\n          }\n\n        case 22:\n          if (!done) {\n            _context.next = 11;\n            break;\n          }\n\n        case 23:\n          _context.next = 28;\n          break;\n\n        case 25:\n          _context.prev = 25;\n          _context.t0 = _context[\"catch\"](10);\n          (threw = true) && typeof it.throw === 'function' && it.throw(_context.t0);\n\n        case 28:\n          _context.prev = 28;\n          threw === false && typeof it.return === 'function' && it.return();\n          return _context.finish(28);\n\n        case 31:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[10, 25, 28, 31]]);\n}\n/** @ignore */\n\n\nfunction _fromAsyncIterable2(_x) {\n  return _fromAsyncIterable.apply(this, arguments);\n} // All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n\n/** @ignore */\n\n\nfunction _fromAsyncIterable() {\n  _fromAsyncIterable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield$2, it, _ref2, _yield$byteRange2;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            byteRange = function _byteRange2() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n\n              var _joinUint8Arrays3 = joinUint8Arrays(buffers, size);\n\n              var _joinUint8Arrays4 = _slicedToArray(_joinUint8Arrays3, 3);\n\n              buffer = _joinUint8Arrays4[0];\n              buffers = _joinUint8Arrays4[1];\n              bufferLength = _joinUint8Arrays4[2];\n              return buffer;\n            };\n\n            threw = false;\n            buffers = [];\n            bufferLength = 0;\n            _context2.next = 6;\n            return null;\n\n          case 6:\n            _yield$2 = _context2.sent;\n            cmd = _yield$2.cmd;\n            size = _yield$2.size;\n            // initialize the iterator\n            it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n            _context2.prev = 10;\n\n          case 11:\n            if (!isNaN(size - bufferLength)) {\n              _context2.next = 17;\n              break;\n            }\n\n            _context2.next = 14;\n            return _awaitAsyncGenerator(it.next(undefined));\n\n          case 14:\n            _context2.t0 = _context2.sent;\n            _context2.next = 20;\n            break;\n\n          case 17:\n            _context2.next = 19;\n            return _awaitAsyncGenerator(it.next(size - bufferLength));\n\n          case 19:\n            _context2.t0 = _context2.sent;\n\n          case 20:\n            _ref2 = _context2.t0;\n            done = _ref2.done;\n            buffer = _ref2.value;\n\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n              buffers.push(buffer);\n              bufferLength += buffer.byteLength;\n            } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n            if (!(done || size <= bufferLength)) {\n              _context2.next = 31;\n              break;\n            }\n\n          case 25:\n            _context2.next = 27;\n            return byteRange();\n\n          case 27:\n            _yield$byteRange2 = _context2.sent;\n            cmd = _yield$byteRange2.cmd;\n            size = _yield$byteRange2.size;\n\n          case 30:\n            if (size < bufferLength) {\n              _context2.next = 25;\n              break;\n            }\n\n          case 31:\n            if (!done) {\n              _context2.next = 11;\n              break;\n            }\n\n          case 32:\n            _context2.next = 40;\n            break;\n\n          case 34:\n            _context2.prev = 34;\n            _context2.t1 = _context2[\"catch\"](10);\n            _context2.t2 = (threw = true) && typeof it.throw === 'function';\n\n            if (!_context2.t2) {\n              _context2.next = 40;\n              break;\n            }\n\n            _context2.next = 40;\n            return _awaitAsyncGenerator(it.throw(_context2.t1));\n\n          case 40:\n            _context2.prev = 40;\n            _context2.t3 = threw === false && typeof it.return === 'function';\n\n            if (!_context2.t3) {\n              _context2.next = 45;\n              break;\n            }\n\n            _context2.next = 45;\n            return _awaitAsyncGenerator(it.return());\n\n          case 45:\n            return _context2.finish(40);\n\n          case 46:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[10, 34, 40, 46]]);\n  }));\n  return _fromAsyncIterable.apply(this, arguments);\n}\n\nfunction _fromDOMStream2(_x2) {\n  return _fromDOMStream.apply(this, arguments);\n}\n/** @ignore */\n\n\nfunction _fromDOMStream() {\n  _fromDOMStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield$3, it, _ref3, _yield$byteRange3;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            byteRange = function _byteRange3() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n\n              var _joinUint8Arrays5 = joinUint8Arrays(buffers, size);\n\n              var _joinUint8Arrays6 = _slicedToArray(_joinUint8Arrays5, 3);\n\n              buffer = _joinUint8Arrays6[0];\n              buffers = _joinUint8Arrays6[1];\n              bufferLength = _joinUint8Arrays6[2];\n              return buffer;\n            };\n\n            done = false, threw = false;\n            buffers = [];\n            bufferLength = 0;\n            _context3.next = 6;\n            return null;\n\n          case 6:\n            _yield$3 = _context3.sent;\n            cmd = _yield$3.cmd;\n            size = _yield$3.size;\n            // initialize the reader and lock the stream\n            it = new AdaptiveByteReader(source);\n            _context3.prev = 10;\n\n          case 11:\n            if (!isNaN(size - bufferLength)) {\n              _context3.next = 17;\n              break;\n            }\n\n            _context3.next = 14;\n            return _awaitAsyncGenerator(it['read'](undefined));\n\n          case 14:\n            _context3.t0 = _context3.sent;\n            _context3.next = 20;\n            break;\n\n          case 17:\n            _context3.next = 19;\n            return _awaitAsyncGenerator(it['read'](size - bufferLength));\n\n          case 19:\n            _context3.t0 = _context3.sent;\n\n          case 20:\n            _ref3 = _context3.t0;\n            done = _ref3.done;\n            buffer = _ref3.value;\n\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n              buffers.push(toUint8Array(buffer));\n              bufferLength += buffer.byteLength;\n            } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n            if (!(done || size <= bufferLength)) {\n              _context3.next = 31;\n              break;\n            }\n\n          case 25:\n            _context3.next = 27;\n            return byteRange();\n\n          case 27:\n            _yield$byteRange3 = _context3.sent;\n            cmd = _yield$byteRange3.cmd;\n            size = _yield$byteRange3.size;\n\n          case 30:\n            if (size < bufferLength) {\n              _context3.next = 25;\n              break;\n            }\n\n          case 31:\n            if (!done) {\n              _context3.next = 11;\n              break;\n            }\n\n          case 32:\n            _context3.next = 40;\n            break;\n\n          case 34:\n            _context3.prev = 34;\n            _context3.t1 = _context3[\"catch\"](10);\n            _context3.t2 = threw = true;\n\n            if (!_context3.t2) {\n              _context3.next = 40;\n              break;\n            }\n\n            _context3.next = 40;\n            return _awaitAsyncGenerator(it['cancel'](_context3.t1));\n\n          case 40:\n            _context3.prev = 40;\n\n            if (!(threw === false)) {\n              _context3.next = 46;\n              break;\n            }\n\n            _context3.next = 44;\n            return _awaitAsyncGenerator(it['cancel']());\n\n          case 44:\n            _context3.next = 47;\n            break;\n\n          case 46:\n            source['locked'] && it.releaseLock();\n\n          case 47:\n            return _context3.finish(40);\n\n          case 48:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2, null, [[10, 34, 40, 48]]);\n  }));\n  return _fromDOMStream.apply(this, arguments);\n}\n\nvar AdaptiveByteReader = /*#__PURE__*/function () {\n  function AdaptiveByteReader(source) {\n    _classCallCheck(this, AdaptiveByteReader);\n\n    this.source = source;\n    this.byobReader = null;\n    this.defaultReader = null;\n\n    try {\n      this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n    } catch (e) {\n      this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n    }\n  }\n\n  _createClass(AdaptiveByteReader, [{\n    key: \"closed\",\n    get: function get() {\n      return this.reader ? this.reader['closed'].catch(function () {}) : Promise.resolve();\n    }\n  }, {\n    key: \"releaseLock\",\n    value: function releaseLock() {\n      if (this.reader) {\n        this.reader.releaseLock();\n      }\n\n      this.reader = this.byobReader = this.defaultReader = null;\n    }\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(reason) {\n        var reader, source;\n        return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                reader = this.reader, source = this.source;\n                _context4.t0 = reader;\n\n                if (!_context4.t0) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                _context4.next = 5;\n                return reader['cancel'](reason).catch(function () {});\n\n              case 5:\n                source && source['locked'] && this.releaseLock();\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function cancel(_x4) {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(size) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(size === 0)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", {\n                  done: this.reader == null,\n                  value: new Uint8Array(0)\n                });\n\n              case 2:\n                if (!(!this.supportsBYOB || typeof size !== 'number')) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                _context5.next = 5;\n                return this.getDefaultReader().read();\n\n              case 5:\n                _context5.t0 = _context5.sent;\n                _context5.next = 11;\n                break;\n\n              case 8:\n                _context5.next = 10;\n                return this.readFromBYOBReader(size);\n\n              case 10:\n                _context5.t0 = _context5.sent;\n\n              case 11:\n                result = _context5.t0;\n                !result.done && (result.value = toUint8Array(result));\n                return _context5.abrupt(\"return\", result);\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function read(_x5) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"getDefaultReader\",\n    value: function getDefaultReader() {\n      if (this.byobReader) {\n        this.releaseLock();\n      }\n\n      if (!this.defaultReader) {\n        this.defaultReader = this.source['getReader'](); // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n\n        this.defaultReader['closed'].catch(function () {});\n      }\n\n      return this.reader = this.defaultReader;\n    }\n  }, {\n    key: \"getBYOBReader\",\n    value: function getBYOBReader() {\n      if (this.defaultReader) {\n        this.releaseLock();\n      }\n\n      if (!this.byobReader) {\n        this.byobReader = this.source['getReader']({\n          mode: 'byob'\n        }); // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n\n        this.byobReader['closed'].catch(function () {});\n      }\n\n      return this.reader = this.byobReader;\n    } // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n\n  }, {\n    key: \"readFromBYOBReader\",\n    value: function () {\n      var _readFromBYOBReader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(size) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n\n              case 2:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function readFromBYOBReader(_x6) {\n        return _readFromBYOBReader.apply(this, arguments);\n      }\n\n      return readFromBYOBReader;\n    }()\n  }]);\n\n  return AdaptiveByteReader;\n}();\n/** @ignore */\n\n\nfunction readInto(_x7, _x8, _x9, _x10) {\n  return _readInto.apply(this, arguments);\n}\n/** @ignore */\n\n\nfunction _readInto() {\n  _readInto = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(reader, buffer, offset, size) {\n    var _yield$reader$read, done, value;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            if (!(offset >= size)) {\n              _context9.next = 2;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", {\n              done: false,\n              value: new Uint8Array(buffer, 0, size)\n            });\n\n          case 2:\n            _context9.next = 4;\n            return reader.read(new Uint8Array(buffer, offset, size - offset));\n\n          case 4:\n            _yield$reader$read = _context9.sent;\n            done = _yield$reader$read.done;\n            value = _yield$reader$read.value;\n\n            if (!((offset += value.byteLength) < size && !done)) {\n              _context9.next = 11;\n              break;\n            }\n\n            _context9.next = 10;\n            return readInto(reader, value.buffer, offset, size);\n\n          case 10:\n            return _context9.abrupt(\"return\", _context9.sent);\n\n          case 11:\n            return _context9.abrupt(\"return\", {\n              done: done,\n              value: new Uint8Array(value.buffer, 0, offset)\n            });\n\n          case 12:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _readInto.apply(this, arguments);\n}\n\nvar onEvent = function onEvent(stream, event) {\n  var handler = function handler(_) {\n    return resolve([event, _]);\n  };\n\n  var resolve;\n  return [event, handler, new Promise(function (r) {\n    return (resolve = r) && stream['once'](event, handler);\n  })];\n};\n/** @ignore */\n\n\nfunction _fromNodeStream2(_x3) {\n  return _fromNodeStream.apply(this, arguments);\n}\n\nfunction _fromNodeStream() {\n  _fromNodeStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(stream) {\n    var events, event, done, err, cmd, size, bufferLength, buffers, buffer, byteRange, _yield$4, _yield$_awaitAsyncGen, _yield$_awaitAsyncGen2, _yield$byteRange4, cleanup;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            cleanup = function _cleanup(events, err) {\n              buffer = buffers = null;\n              return new Promise( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(resolve, reject) {\n                  var _iterator, _step, _step$value, evt, fn, destroy;\n\n                  return _regeneratorRuntime.wrap(function _callee6$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          _iterator = _createForOfIteratorHelper(events);\n\n                          try {\n                            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                              _step$value = _slicedToArray(_step.value, 2), evt = _step$value[0], fn = _step$value[1];\n                              stream['off'](evt, fn);\n                            }\n                          } catch (err) {\n                            _iterator.e(err);\n                          } finally {\n                            _iterator.f();\n                          }\n\n                          try {\n                            // Some stream implementations don't call the destroy callback,\n                            // because it's really a node-internal API. Just calling `destroy`\n                            // here should be enough to conform to the ReadableStream contract\n                            destroy = stream['destroy'];\n                            destroy && destroy.call(stream, err);\n                            err = undefined;\n                          } catch (e) {\n                            err = e || err;\n                          } finally {\n                            err != null ? reject(err) : resolve();\n                          }\n\n                        case 3:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee6);\n                }));\n\n                return function (_x11, _x12) {\n                  return _ref4.apply(this, arguments);\n                };\n              }());\n            };\n\n            byteRange = function _byteRange4() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n\n              var _joinUint8Arrays7 = joinUint8Arrays(buffers, size);\n\n              var _joinUint8Arrays8 = _slicedToArray(_joinUint8Arrays7, 3);\n\n              buffer = _joinUint8Arrays8[0];\n              buffers = _joinUint8Arrays8[1];\n              bufferLength = _joinUint8Arrays8[2];\n              return buffer;\n            };\n\n            events = [];\n            event = 'error';\n            done = false, err = null;\n            bufferLength = 0;\n            buffers = [];\n            _context8.next = 9;\n            return null;\n\n          case 9:\n            _yield$4 = _context8.sent;\n            cmd = _yield$4.cmd;\n            size = _yield$4.size;\n\n            if (!stream['isTTY']) {\n              _context8.next = 16;\n              break;\n            }\n\n            _context8.next = 15;\n            return new Uint8Array(0);\n\n          case 15:\n            return _context8.abrupt(\"return\", _context8.sent);\n\n          case 16:\n            _context8.prev = 16;\n            // initialize the stream event handlers\n            events[0] = onEvent(stream, 'end');\n            events[1] = onEvent(stream, 'error');\n\n          case 19:\n            events[2] = onEvent(stream, 'readable'); // wait on the first message event from the stream\n\n            _context8.next = 22;\n            return _awaitAsyncGenerator(Promise.race(events.map(function (x) {\n              return x[2];\n            })));\n\n          case 22:\n            _yield$_awaitAsyncGen = _context8.sent;\n            _yield$_awaitAsyncGen2 = _slicedToArray(_yield$_awaitAsyncGen, 2);\n            event = _yield$_awaitAsyncGen2[0];\n            err = _yield$_awaitAsyncGen2[1];\n\n            if (!(event === 'error')) {\n              _context8.next = 28;\n              break;\n            }\n\n            return _context8.abrupt(\"break\", 37);\n\n          case 28:\n            if (!(done = event === 'end')) {\n              // If the size is NaN, request to read everything in the stream's internal buffer\n              if (!isFinite(size - bufferLength)) {\n                buffer = toUint8Array(stream['read'](undefined));\n              } else {\n                buffer = toUint8Array(stream['read'](size - bufferLength)); // If the byteLength is 0, then the requested amount is more than the stream has\n                // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                // continue emitting readable events, so request to read everything the stream\n                // has in its internal buffer right now.\n\n                if (buffer.byteLength < size - bufferLength) {\n                  buffer = toUint8Array(stream['read'](undefined));\n                }\n              } // if chunk is not null or empty, push it onto the queue\n\n\n              if (buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n              }\n            } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n            if (!(done || size <= bufferLength)) {\n              _context8.next = 36;\n              break;\n            }\n\n          case 30:\n            _context8.next = 32;\n            return byteRange();\n\n          case 32:\n            _yield$byteRange4 = _context8.sent;\n            cmd = _yield$byteRange4.cmd;\n            size = _yield$byteRange4.size;\n\n          case 35:\n            if (size < bufferLength) {\n              _context8.next = 30;\n              break;\n            }\n\n          case 36:\n            if (!done) {\n              _context8.next = 19;\n              break;\n            }\n\n          case 37:\n            _context8.prev = 37;\n            _context8.next = 40;\n            return _awaitAsyncGenerator(cleanup(events, event === 'error' ? err : null));\n\n          case 40:\n            return _context8.finish(37);\n\n          case 41:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee7, null, [[16,, 37, 41]]);\n  }));\n  return _fromNodeStream.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["fromIterable","toUint8Array","joinUint8Arrays","toUint8ArrayIterator","toUint8ArrayAsyncIterator","source","pump","fromAsyncIterable","fromDOMStream","fromNodeStream","stream","toDOMStream","options","Error","toNodeStream","iterator","next","byteRange","cmd","buffers","size","buffer","bufferLength","threw","it","Symbol","isNaN","undefined","done","value","byteLength","push","throw","return","asyncIterator","AdaptiveByteReader","releaseLock","supportsBYOB","reader","getBYOBReader","e","getDefaultReader","catch","Promise","resolve","byobReader","defaultReader","reason","Uint8Array","read","readFromBYOBReader","result","mode","readInto","ArrayBuffer","offset","onEvent","event","handler","_","r","cleanup","events","err","reject","evt","fn","destroy","call","race","map","x","isFinite"],"sources":["io/adapters.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer';\n\nimport { ReadableDOMStreamOptions } from './interfaces';\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Iterator<any> | AsyncIterator<any>>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength) ?\n                it.next(undefined) : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return());\n    }\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it.next(undefined)\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return());\n    }\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the reader and lock the stream\n    let it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it['read'](undefined)\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private supportsBYOB: boolean;\n    private byobReader: ReadableStreamBYOBReader | null = null;\n    private defaultReader: ReadableStreamDefaultReader<T> | null = null;\n    private reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader<T> | null;\n\n    constructor(private source: ReadableStream<T>) {\n        try {\n            this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n        } catch (e) {\n            this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n        }\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = this.byobReader = this.defaultReader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => {}));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) };\n        }\n        const result = !this.supportsBYOB || typeof size !== 'number'\n            ? await this.getDefaultReader().read()\n            : await this.readFromBYOBReader(size);\n        !result.done && (result.value = toUint8Array(result as ReadableStreamReadResult<Uint8Array>));\n        return result as ReadableStreamReadResult<Uint8Array>;\n    }\n\n    private getDefaultReader() {\n        if (this.byobReader) { this.releaseLock(); }\n        if (!this.defaultReader) {\n            this.defaultReader = this.source['getReader']();\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.defaultReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.defaultReader);\n    }\n\n    private getBYOBReader() {\n        if (this.defaultReader) { this.releaseLock(); }\n        if (!this.byobReader) {\n            this.byobReader = this.source['getReader']({ mode: 'byob' });\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.byobReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.byobReader);\n    }\n\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n    private async readFromBYOBReader(size: number) {\n        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n    }\n}\n\n/** @ignore */\nasync function readInto(reader: ReadableStreamBYOBReader, buffer: ArrayBufferLike, offset: number, size: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n    if (offset >= size) {\n        return { done: false, value: new Uint8Array(buffer, 0, size) };\n    }\n    const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n    if (((offset += value.byteLength) < size) && !done) {\n        return await readInto(reader, value.buffer, offset, size);\n    }\n    return { done, value: new Uint8Array(value.buffer, 0, offset) };\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    let handler = (_: any) => resolve([event, _]);\n    let resolve: (value?: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n\n    let events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any> null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) { return yield new Uint8Array(0); }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read'](undefined));\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if (buffer.byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read'](undefined));\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if (buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any> null;\n        return new Promise<T>(async (resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}