{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toArrayBufferView } from './buffer';\nimport { BigIntAvailable, BigInt64Array, BigUint64Array } from './compat';\n/** @ignore */\n\nexport const isArrowBigNumSymbol = Symbol.for('isArrowBigNum');\n/** @ignore */\n\nfunction BigNum(x) {\n  for (var _len = arguments.length, xs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    xs[_key - 1] = arguments[_key];\n  }\n\n  if (xs.length === 0) {\n    return Object.setPrototypeOf(toArrayBufferView(this['TypedArray'], x), this.constructor.prototype);\n  }\n\n  return Object.setPrototypeOf(new this['TypedArray'](x, ...xs), this.constructor.prototype);\n}\n\nBigNum.prototype[isArrowBigNumSymbol] = true;\n\nBigNum.prototype.toJSON = function () {\n  return `\"${bignumToString(this)}\"`;\n};\n\nBigNum.prototype.valueOf = function () {\n  return bignumToNumber(this);\n};\n\nBigNum.prototype.toString = function () {\n  return bignumToString(this);\n};\n\nBigNum.prototype[Symbol.toPrimitive] = function () {\n  let hint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n\n  switch (hint) {\n    case 'number':\n      return bignumToNumber(this);\n\n    case 'string':\n      return bignumToString(this);\n\n    case 'default':\n      return bignumToBigInt(this);\n  }\n\n  return bignumToString(this);\n};\n/** @ignore */\n\n\nfunction SignedBigNum() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return BigNum.apply(this, args);\n}\n/** @ignore */\n\n\nfunction UnsignedBigNum() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return BigNum.apply(this, args);\n}\n/** @ignore */\n\n\nfunction DecimalBigNum() {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  return BigNum.apply(this, args);\n}\n\nObject.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));\nObject.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.assign(SignedBigNum.prototype, BigNum.prototype, {\n  'constructor': SignedBigNum,\n  'signed': true,\n  'TypedArray': Int32Array,\n  'BigIntArray': BigInt64Array\n});\nObject.assign(UnsignedBigNum.prototype, BigNum.prototype, {\n  'constructor': UnsignedBigNum,\n  'signed': false,\n  'TypedArray': Uint32Array,\n  'BigIntArray': BigUint64Array\n});\nObject.assign(DecimalBigNum.prototype, BigNum.prototype, {\n  'constructor': DecimalBigNum,\n  'signed': true,\n  'TypedArray': Uint32Array,\n  'BigIntArray': BigUint64Array\n});\n/** @ignore */\n\nfunction bignumToNumber(bn) {\n  let {\n    buffer,\n    byteOffset,\n    length,\n    'signed': signed\n  } = bn;\n  let words = new Int32Array(buffer, byteOffset, length);\n  let number = 0,\n      i = 0,\n      n = words.length,\n      hi,\n      lo;\n\n  while (i < n) {\n    lo = words[i++];\n    hi = words[i++];\n    signed || (hi = hi >>> 0);\n    number += (lo >>> 0) + hi * i ** 32;\n  }\n\n  return number;\n}\n/** @ignore */\n\n\nexport let bignumToString;\n/** @ignore */\n\nexport let bignumToBigInt;\n\nif (!BigIntAvailable) {\n  bignumToString = decimalToString;\n  bignumToBigInt = bignumToString;\n} else {\n  bignumToBigInt = a => a.byteLength === 8 ? new a['BigIntArray'](a.buffer, a.byteOffset, 1)[0] : decimalToString(a);\n\n  bignumToString = a => a.byteLength === 8 ? `${new a['BigIntArray'](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a);\n}\n/** @ignore */\n\n\nfunction decimalToString(a) {\n  let digits = '';\n  let base64 = new Uint32Array(2);\n  let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);\n  let checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);\n  let i = -1,\n      n = base32.length - 1;\n\n  do {\n    for (base64[0] = base32[i = 0]; i < n;) {\n      base32[i++] = base64[1] = base64[0] / 10;\n      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];\n    }\n\n    base32[i] = base64[1] = base64[0] / 10;\n    base64[0] = base64[0] - base64[1] * 10;\n    digits = `${base64[0]}${digits}`;\n  } while (checks[0] || checks[1] || checks[2] || checks[3]);\n\n  return digits ? digits : `0`;\n}\n/** @ignore */\n\n\nexport class BN {\n  constructor(num, isSigned) {\n    return BN.new(num, isSigned);\n  }\n  /** @nocollapse */\n\n\n  static new(num, isSigned) {\n    switch (isSigned) {\n      case true:\n        return new SignedBigNum(num);\n\n      case false:\n        return new UnsignedBigNum(num);\n    }\n\n    switch (num.constructor) {\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case BigInt64Array:\n        return new SignedBigNum(num);\n    }\n\n    if (num.byteLength === 16) {\n      return new DecimalBigNum(num);\n    }\n\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n\n\n  static signed(num) {\n    return new SignedBigNum(num);\n  }\n  /** @nocollapse */\n\n\n  static unsigned(num) {\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n\n\n  static decimal(num) {\n    return new DecimalBigNum(num);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["toArrayBufferView","BigIntAvailable","BigInt64Array","BigUint64Array","isArrowBigNumSymbol","Symbol","for","BigNum","x","xs","length","Object","setPrototypeOf","constructor","prototype","toJSON","bignumToString","valueOf","bignumToNumber","toString","toPrimitive","hint","bignumToBigInt","SignedBigNum","args","apply","UnsignedBigNum","DecimalBigNum","create","Int32Array","Uint32Array","assign","bn","buffer","byteOffset","signed","words","number","i","n","hi","lo","decimalToString","a","byteLength","digits","base64","base32","Uint16Array","checks","reverse","BN","num","isSigned","new","Int8Array","Int16Array","unsigned","decimal"],"sources":["util/bn.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { ArrayBufferViewInput, toArrayBufferView } from './buffer';\nimport { TypedArray, TypedArrayConstructor } from '../interfaces';\nimport { BigIntArray, BigIntArrayConstructor } from '../interfaces';\nimport { BigIntAvailable, BigInt64Array, BigUint64Array } from './compat';\n\n/** @ignore */\nexport const isArrowBigNumSymbol = Symbol.for('isArrowBigNum');\n\n/** @ignore */ type BigNumArray = IntArray | UintArray;\n/** @ignore */ type IntArray = Int8Array | Int16Array | Int32Array;\n/** @ignore */ type UintArray = Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray;\n\n/** @ignore */\nfunction BigNum(this: any, x: any, ...xs: any) {\n    if (xs.length === 0) {\n        return Object.setPrototypeOf(toArrayBufferView(this['TypedArray'], x), this.constructor.prototype);\n    }\n    return Object.setPrototypeOf(new this['TypedArray'](x, ...xs), this.constructor.prototype);\n}\n\nBigNum.prototype[isArrowBigNumSymbol] = true;\nBigNum.prototype.toJSON = function<T extends BN<BigNumArray>>(this: T) { return `\"${bignumToString(this)}\"`; };\nBigNum.prototype.valueOf = function<T extends BN<BigNumArray>>(this: T) { return bignumToNumber(this); };\nBigNum.prototype.toString = function<T extends BN<BigNumArray>>(this: T) { return bignumToString(this); };\nBigNum.prototype[Symbol.toPrimitive] = function<T extends BN<BigNumArray>>(this: T, hint: 'string' | 'number' | 'default' = 'default') {\n    switch (hint) {\n        case 'number': return bignumToNumber(this);\n        case 'string': return bignumToString(this);\n        case 'default': return bignumToBigInt(this);\n    }\n    return bignumToString(this);\n};\n\n/** @ignore */\ntype TypedArrayConstructorArgs =\n    [number | void] |\n    [Iterable<number> | Iterable<bigint>] |\n    [ArrayBufferLike, number | void, number | void] ;\n\n/** @ignore */\nfunction SignedBigNum(this: any, ...args: TypedArrayConstructorArgs) { return BigNum.apply(this, args); }\n/** @ignore */\nfunction UnsignedBigNum(this: any, ...args: TypedArrayConstructorArgs) { return BigNum.apply(this, args); }\n/** @ignore */\nfunction DecimalBigNum(this: any, ...args: TypedArrayConstructorArgs) { return BigNum.apply(this, args); }\n\nObject.setPrototypeOf(SignedBigNum.prototype,   Object.create(Int32Array.prototype));\nObject.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.setPrototypeOf(DecimalBigNum.prototype,  Object.create(Uint32Array.prototype));\nObject.assign(SignedBigNum.prototype,   BigNum.prototype, { 'constructor': SignedBigNum,   'signed': true,  'TypedArray': Int32Array,  'BigIntArray': BigInt64Array  });\nObject.assign(UnsignedBigNum.prototype, BigNum.prototype, { 'constructor': UnsignedBigNum, 'signed': false, 'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });\nObject.assign(DecimalBigNum.prototype,  BigNum.prototype, { 'constructor': DecimalBigNum,  'signed': true,  'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });\n\n/** @ignore */\nfunction bignumToNumber<T extends BN<BigNumArray>>(bn: T) {\n    let { buffer, byteOffset, length, 'signed': signed } = bn;\n    let words = new Int32Array(buffer, byteOffset, length);\n    let number = 0, i = 0, n = words.length, hi, lo;\n    while (i < n) {\n        lo = words[i++];\n        hi = words[i++];\n        signed || (hi = hi >>> 0);\n        number += (lo >>> 0) + (hi * (i ** 32));\n    }\n    return number;\n}\n\n/** @ignore */\nexport let bignumToString: { <T extends BN<BigNumArray>>(a: T): string; };\n/** @ignore */\nexport let bignumToBigInt: { <T extends BN<BigNumArray>>(a: T): bigint; };\n\nif (!BigIntAvailable) {\n    bignumToString = decimalToString;\n    bignumToBigInt = <any> bignumToString;\n} else {\n    bignumToBigInt = (<T extends BN<BigNumArray>>(a: T) => a.byteLength === 8 ? new a['BigIntArray'](a.buffer, a.byteOffset, 1)[0] : <any>decimalToString(a));\n    bignumToString = (<T extends BN<BigNumArray>>(a: T) => a.byteLength === 8 ? `${new a['BigIntArray'](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a));\n}\n\n/** @ignore */\nfunction decimalToString<T extends BN<BigNumArray>>(a: T) {\n    let digits = '';\n    let base64 = new Uint32Array(2);\n    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);\n    let checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);\n    let i = -1, n = base32.length - 1;\n    do {\n        for (base64[0] = base32[i = 0]; i < n;) {\n            base32[i++] = base64[1] = base64[0] / 10;\n            base64[0] = ((base64[0] - base64[1] * 10) << 16) + base32[i];\n        }\n        base32[i] = base64[1] = base64[0] / 10;\n        base64[0] = base64[0] - base64[1] * 10;\n        digits = `${base64[0]}${digits}`;\n    } while (checks[0] || checks[1] || checks[2] || checks[3]);\n    return digits ? digits : `0`;\n}\n\n/** @ignore */\nexport class BN<T extends BigNumArray> {\n    /** @nocollapse */\n    public static new<T extends BigNumArray>(num: T, isSigned?: boolean): (T & BN<T>) {\n        switch (isSigned) {\n            case true: return new (<any> SignedBigNum)(num) as (T & BN<T>);\n            case false: return new (<any> UnsignedBigNum)(num) as (T & BN<T>);\n        }\n        switch (num.constructor) {\n            case Int8Array:\n            case Int16Array:\n            case Int32Array:\n            case BigInt64Array:\n                return new (<any> SignedBigNum)(num) as (T & BN<T>);\n        }\n        if (num.byteLength === 16) {\n            return new (<any> DecimalBigNum)(num) as (T & BN<T>);\n        }\n        return new (<any> UnsignedBigNum)(num) as (T & BN<T>);\n    }\n    /** @nocollapse */\n    public static signed<T extends IntArray>(num: T): (T & BN<T>) {\n        return new (<any> SignedBigNum)(num) as (T & BN<T>);\n    }\n    /** @nocollapse */\n    public static unsigned<T extends UintArray>(num: T): (T & BN<T>) {\n        return new (<any> UnsignedBigNum)(num) as (T & BN<T>);\n    }\n    /** @nocollapse */\n    public static decimal<T extends UintArray>(num: T): (T & BN<T>) {\n        return new (<any> DecimalBigNum)(num) as (T & BN<T>);\n    }\n    constructor(num: T, isSigned?: boolean) {\n        return BN.new(num, isSigned) as any;\n    }\n}\n\n/** @ignore */\nexport interface BN<T extends BigNumArray> extends TypedArrayLike<T> {\n\n    new<T extends ArrayBufferViewInput>(buffer: T, signed?: boolean): T;\n\n    readonly signed: boolean;\n    readonly TypedArray: TypedArrayConstructor<TypedArray>;\n    readonly BigIntArray: BigIntArrayConstructor<BigIntArray>;\n\n    [Symbol.toStringTag]:\n        'Int8Array'         |\n        'Int16Array'        |\n        'Int32Array'        |\n        'Uint8Array'        |\n        'Uint16Array'       |\n        'Uint32Array'       |\n        'Uint8ClampedArray';\n\n    /**\n     * Convert the bytes to their (positive) decimal representation for printing\n     */\n    toString(): string;\n    /**\n     * Down-convert the bytes to a 53-bit precision integer. Invoked by JS for\n     * arithmetic operators, like `+`. Easy (and unsafe) way to convert BN to\n     * number via `+bn_inst`\n     */\n    valueOf(): number;\n    /**\n     * Return the JSON representation of the bytes. Must be wrapped in double-quotes,\n     * so it's compatible with JSON.stringify().\n     */\n    toJSON(): string;\n    [Symbol.toPrimitive](hint?: any): number | string | bigint;\n}\n\n/** @ignore */\ninterface TypedArrayLike<T extends BigNumArray> {\n\n    readonly length: number;\n    readonly buffer: ArrayBuffer;\n    readonly byteLength: number;\n    readonly byteOffset: number;\n    readonly BYTES_PER_ELEMENT: number;\n\n    includes(searchElement: number, fromIndex?: number | undefined): boolean;\n    copyWithin(target: number, start: number, end?: number | undefined): this;\n    every(callbackfn: (value: number, index: number, array: T) => boolean, thisArg?: any): boolean;\n    fill(value: number, start?: number | undefined, end?: number | undefined): this;\n    filter(callbackfn: (value: number, index: number, array: T) => boolean, thisArg?: any): T;\n    find(predicate: (value: number, index: number, obj: T) => boolean, thisArg?: any): number | undefined;\n    findIndex(predicate: (value: number, index: number, obj: T) => boolean, thisArg?: any): number;\n    forEach(callbackfn: (value: number, index: number, array: T) => void, thisArg?: any): void;\n    indexOf(searchElement: number, fromIndex?: number | undefined): number;\n    join(separator?: string | undefined): string;\n    lastIndexOf(searchElement: number, fromIndex?: number | undefined): number;\n    map(callbackfn: (value: number, index: number, array: T) => number, thisArg?: any): T;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: T) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: T) => number, initialValue: number): number;\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: T) => U, initialValue: U): U;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: T) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: T) => number, initialValue: number): number;\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: T) => U, initialValue: U): U;\n    reverse(): T;\n    set(array: ArrayLike<number>, offset?: number | undefined): void;\n    slice(start?: number | undefined, end?: number | undefined): T;\n    some(callbackfn: (value: number, index: number, array: T) => boolean, thisArg?: any): boolean;\n    sort(compareFn?: ((a: number, b: number) => number) | undefined): this;\n    subarray(begin: number, end?: number | undefined): T;\n    toLocaleString(): string;\n    entries(): IterableIterator<[number, number]>;\n    keys(): IterableIterator<number>;\n    values(): IterableIterator<number>;\n}\n"]},"metadata":{},"sourceType":"module"}