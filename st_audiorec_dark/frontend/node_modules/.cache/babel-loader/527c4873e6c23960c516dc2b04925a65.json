{"ast":null,"code":"import _objectSpread from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { AsyncByteQueue } from '../../io/stream';\nimport { RecordBatchReader } from '../../ipc/reader';\n/** @ignore */\n\nexport function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {\n  var queue = new AsyncByteQueue();\n  var reader = null;\n  var readable = new ReadableStream({\n    cancel: function cancel() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return queue.close();\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n    start: function start(controller) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = next;\n                _context2.t1 = controller;\n                _context2.t2 = reader;\n\n                if (_context2.t2) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 6;\n                return open();\n\n              case 6:\n                _context2.t2 = reader = _context2.sent;\n\n              case 7:\n                _context2.t3 = _context2.t2;\n                _context2.next = 10;\n                return (0, _context2.t0)(_context2.t1, _context2.t3);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    pull: function pull(controller) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!reader) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                _context3.next = 3;\n                return next(controller, reader);\n\n              case 3:\n                _context3.next = 6;\n                break;\n\n              case 5:\n                controller.close();\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  });\n  return {\n    writable: new WritableStream(queue, _objectSpread({\n      'highWaterMark': Math.pow(2, 14)\n    }, writableStrategy)),\n    readable: readable\n  };\n\n  function open() {\n    return _open.apply(this, arguments);\n  }\n\n  function _open() {\n    _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return RecordBatchReader.from(queue);\n\n            case 2:\n              _context4.next = 4;\n              return _context4.sent.open(readableStrategy);\n\n            case 4:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _open.apply(this, arguments);\n  }\n\n  function next(_x, _x2) {\n    return _next.apply(this, arguments);\n  }\n\n  function _next() {\n    _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(controller, reader) {\n      var size, r;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              size = controller.desiredSize;\n              r = null;\n\n            case 2:\n              _context5.next = 4;\n              return reader.next();\n\n            case 4:\n              if ((r = _context5.sent).done) {\n                _context5.next = 10;\n                break;\n              }\n\n              controller.enqueue(r.value);\n\n              if (!(size != null && --size <= 0)) {\n                _context5.next = 8;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 8:\n              _context5.next = 2;\n              break;\n\n            case 10:\n              controller.close();\n\n            case 11:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    return _next.apply(this, arguments);\n  }\n}","map":{"version":3,"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SAASA,cAAT,QAA+B,iBAA/B;AACA,SAASC,iBAAT,QAAkC,kBAAlC;AAEA;;AACA,OAAM,SAAUC,iCAAV,CAAyFC,gBAAzF,EAAuIC,gBAAvI,EAAkL;AAEpL,MAAMC,KAAK,GAAG,IAAIL,cAAJ,EAAd;AACA,MAAIM,MAAM,GAAgC,IAA1C;AAEA,MAAMC,QAAQ,GAAG,IAAIC,cAAJ,CAAmC;AAC1CC,UAD0C,oBACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAWJ,KAAK,CAACK,KAAN,EAAX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2B,KADS;AAE1CC,SAF0C,iBAEpCC,UAFoC,EAE1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAUC,IAAV;AAAA,+BAAeD,UAAf;AAAA,+BAA2BN,MAA3B;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAAqDQ,IAAI,EAAzD;;AAAA;AAAA,+BAAsCR,MAAtC;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgE,KAFtC;AAG1CS,QAH0C,gBAGrCH,UAHqC,EAG3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAIN,MAAJ;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAAmBO,IAAI,CAACD,UAAD,EAAaN,MAAb,CAAvB;;AAAA;AAAA;AAAA;;AAAA;AAA8CM,0BAAU,CAACF,KAAX,EAA9C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmE;AAHxC,GAAnC,CAAjB;AAMA,SAAO;AAAEM,YAAQ,EAAE,IAAIC,cAAJ,CAAmBZ,KAAnB;AAA4B,gCAAiB,CAAjB,EAAsB,EAAtB;AAA5B,OAAyDF,gBAAzD,EAAZ;AAA0FI,YAAQ,EAARA;AAA1F,GAAP;;AAXoL,WAarKO,IAbqK;AAAA;AAAA;;AAAA;AAAA,qEAapL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBACwBb,iBAAiB,CAACiB,IAAlB,CAA0Bb,KAA1B,CADxB;;AAAA;AAAA;AAAA,oCAC0DS,IAD1D,CAC+DV,gBAD/D;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAboL;AAAA;AAAA;;AAAA,WAiBrKS,IAjBqK;AAAA;AAAA;;AAAA;AAAA,qEAiBpL,kBAAoBD,UAApB,EAAiFN,MAAjF;AAAA;AAAA;AAAA;AAAA;AAAA;AACQa,kBADR,GACeP,UAAU,CAACQ,WAD1B;AAEQC,eAFR,GAEmD,IAFnD;;AAAA;AAAA;AAAA,qBAGuBf,MAAM,CAACO,IAAP,EAHvB;;AAAA;AAAA,mBAGaQ,CAHb,mBAGsCC,IAHtC;AAAA;AAAA;AAAA;;AAIQV,wBAAU,CAACW,OAAX,CAAmBF,CAAC,CAACG,KAArB;;AAJR,oBAKYL,IAAI,IAAI,IAAR,IAAgB,EAAEA,IAAF,IAAU,CALtC;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AASIP,wBAAU,CAACF,KAAX;;AATJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAjBoL;AAAA;AAAA;AA4BvL","names":["AsyncByteQueue","RecordBatchReader","recordBatchReaderThroughDOMStream","writableStrategy","readableStrategy","queue","reader","readable","ReadableStream","cancel","close","start","controller","next","open","pull","writable","WritableStream","from","size","desiredSize","r","done","enqueue","value"],"sources":["io/whatwg/reader.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { DataType } from '../../type';\nimport { RecordBatch } from '../../recordbatch';\nimport { AsyncByteQueue } from '../../io/stream';\nimport { RecordBatchReader } from '../../ipc/reader';\n\n/** @ignore */\nexport function recordBatchReaderThroughDOMStream<T extends { [key: string]: DataType } = any>(writableStrategy?: ByteLengthQueuingStrategy, readableStrategy?: { autoDestroy: boolean }) {\n\n    const queue = new AsyncByteQueue();\n    let reader: RecordBatchReader<T> | null = null;\n\n    const readable = new ReadableStream<RecordBatch<T>>({\n        async cancel() { await queue.close(); },\n        async start(controller) { await next(controller, reader || (reader = await open())); },\n        async pull(controller) { reader ? await next(controller, reader) : controller.close(); }\n    });\n\n    return { writable: new WritableStream(queue, { 'highWaterMark': 2 ** 14, ...writableStrategy }), readable };\n\n    async function open() {\n        return await (await RecordBatchReader.from<T>(queue)).open(readableStrategy);\n    }\n\n    async function next(controller: ReadableStreamDefaultController<RecordBatch<T>>, reader: RecordBatchReader<T>) {\n        let size = controller.desiredSize;\n        let r: IteratorResult<RecordBatch<T>> | null = null;\n        while (!(r = await reader.next()).done) {\n            controller.enqueue(r.value);\n            if (size != null && --size <= 0) {\n                return;\n            }\n        }\n        controller.close();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}