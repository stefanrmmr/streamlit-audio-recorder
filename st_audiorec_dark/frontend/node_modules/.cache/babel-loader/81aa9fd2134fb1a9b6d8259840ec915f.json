{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","map":{"version":3,"sources":["/Users/stefan_rmmr/software_dev/beat_inspector/st_audiorec/frontend/node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js"],"names":["module","exports","Readable","Duplex","ReadableState","EE","require","EventEmitter","EElistenerCount","emitter","type","listeners","length","Stream","Buffer","OurUint8Array","global","Uint8Array","_uint8ArrayToBuffer","chunk","from","_isUint8Array","obj","isBuffer","debugUtil","debug","debuglog","BufferList","destroyImpl","_require","getHighWaterMark","_require$codes","codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","StringDecoder","createReadableStreamAsyncIterator","errorOrDestroy","kProxyEvents","prependListener","event","fn","_events","on","Array","isArray","unshift","options","stream","isDuplex","objectMode","readableObjectMode","highWaterMark","buffer","pipes","pipesCount","flowing","ended","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","paused","emitClose","autoDestroy","destroyed","defaultEncoding","awaitDrain","readingMore","decoder","encoding","_readableState","readable","read","_read","destroy","_destroy","call","Object","defineProperty","prototype","enumerable","get","undefined","set","value","_undestroy","undestroy","err","cb","push","state","skipChunkCheck","readableAddChunk","addToFront","onEofChunk","er","chunkInvalid","getPrototypeOf","addChunk","write","maybeReadMore","emit","emitReadable","isPaused","setEncoding","enc","p","head","content","data","next","clear","MAX_HWM","computeNewHighWaterMark","n","howMuchToRead","parseInt","nOrig","endReadable","doRead","ret","fromList","end","emitReadable_","process","nextTick","flow","maybeReadMore_","len","pipe","dest","pipeOpts","src","doEnd","stdout","stderr","endFn","onend","unpipe","once","onunpipe","unpipeInfo","hasUnpiped","cleanup","ondrain","pipeOnDrain","cleanedUp","removeListener","onclose","onfinish","onerror","ondata","_writableState","needDrain","indexOf","pause","resume","pipeOnDrainFunctionResult","dests","i","index","splice","ev","res","listenerCount","nReadingNextTick","addListener","updateReadableListening","removeAllListeners","apply","arguments","self","resume_","wrap","_this","methodWrap","method","methodWrapReturnFunction","bind","Symbol","asyncIterator","_fromList","shift","join","first","concat","consume","endReadableNT","wState","finished","iterable","opts","xs","x","l"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,QAAjB;AACA;;AAEA,IAAIC,MAAJ;AACA;;AAEAD,QAAQ,CAACE,aAAT,GAAyBA,aAAzB;AACA;;AAEA,IAAIC,EAAE,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBC,YAA3B;;AAEA,IAAIC,eAAe,GAAG,SAASA,eAAT,CAAyBC,OAAzB,EAAkCC,IAAlC,EAAwC;AAC5D,SAAOD,OAAO,CAACE,SAAR,CAAkBD,IAAlB,EAAwBE,MAA/B;AACD,CAFD;AAGA;;AAEA;;;AAGA,IAAIC,MAAM,GAAGP,OAAO,CAAC,2BAAD,CAApB;AACA;;;AAGA,IAAIQ,MAAM,GAAGR,OAAO,CAAC,QAAD,CAAP,CAAkBQ,MAA/B;;AAEA,IAAIC,aAAa,GAAGC,MAAM,CAACC,UAAP,IAAqB,YAAY,CAAE,CAAvD;;AAEA,SAASC,mBAAT,CAA6BC,KAA7B,EAAoC;AAClC,SAAOL,MAAM,CAACM,IAAP,CAAYD,KAAZ,CAAP;AACD;;AAED,SAASE,aAAT,CAAuBC,GAAvB,EAA4B;AAC1B,SAAOR,MAAM,CAACS,QAAP,CAAgBD,GAAhB,KAAwBA,GAAG,YAAYP,aAA9C;AACD;AACD;;;AAGA,IAAIS,SAAS,GAAGlB,OAAO,CAAC,MAAD,CAAvB;;AAEA,IAAImB,KAAJ;;AAEA,IAAID,SAAS,IAAIA,SAAS,CAACE,QAA3B,EAAqC;AACnCD,EAAAA,KAAK,GAAGD,SAAS,CAACE,QAAV,CAAmB,QAAnB,CAAR;AACD,CAFD,MAEO;AACLD,EAAAA,KAAK,GAAG,SAASA,KAAT,GAAiB,CAAE,CAA3B;AACD;AACD;;;AAGA,IAAIE,UAAU,GAAGrB,OAAO,CAAC,gCAAD,CAAxB;;AAEA,IAAIsB,WAAW,GAAGtB,OAAO,CAAC,4BAAD,CAAzB;;AAEA,IAAIuB,QAAQ,GAAGvB,OAAO,CAAC,0BAAD,CAAtB;AAAA,IACIwB,gBAAgB,GAAGD,QAAQ,CAACC,gBADhC;;AAGA,IAAIC,cAAc,GAAGzB,OAAO,CAAC,WAAD,CAAP,CAAqB0B,KAA1C;AAAA,IACIC,oBAAoB,GAAGF,cAAc,CAACE,oBAD1C;AAAA,IAEIC,yBAAyB,GAAGH,cAAc,CAACG,yBAF/C;AAAA,IAGIC,0BAA0B,GAAGJ,cAAc,CAACI,0BAHhD;AAAA,IAIIC,kCAAkC,GAAGL,cAAc,CAACK,kCAJxD,C,CAI4F;;;AAG5F,IAAIC,aAAJ;AACA,IAAIC,iCAAJ;AACA,IAAIlB,IAAJ;;AAEAd,OAAO,CAAC,UAAD,CAAP,CAAoBJ,QAApB,EAA8BW,MAA9B;;AAEA,IAAI0B,cAAc,GAAGX,WAAW,CAACW,cAAjC;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,SAAnB,EAA8B,OAA9B,EAAuC,QAAvC,CAAnB;;AAEA,SAASC,eAAT,CAAyBhC,OAAzB,EAAkCiC,KAAlC,EAAyCC,EAAzC,EAA6C;AAC3C;AACA;AACA,MAAI,OAAOlC,OAAO,CAACgC,eAAf,KAAmC,UAAvC,EAAmD,OAAOhC,OAAO,CAACgC,eAAR,CAAwBC,KAAxB,EAA+BC,EAA/B,CAAP,CAHR,CAGmD;AAC9F;AACA;AACA;;AAEA,MAAI,CAAClC,OAAO,CAACmC,OAAT,IAAoB,CAACnC,OAAO,CAACmC,OAAR,CAAgBF,KAAhB,CAAzB,EAAiDjC,OAAO,CAACoC,EAAR,CAAWH,KAAX,EAAkBC,EAAlB,EAAjD,KAA4E,IAAIG,KAAK,CAACC,OAAN,CAActC,OAAO,CAACmC,OAAR,CAAgBF,KAAhB,CAAd,CAAJ,EAA2CjC,OAAO,CAACmC,OAAR,CAAgBF,KAAhB,EAAuBM,OAAvB,CAA+BL,EAA/B,EAA3C,KAAmFlC,OAAO,CAACmC,OAAR,CAAgBF,KAAhB,IAAyB,CAACC,EAAD,EAAKlC,OAAO,CAACmC,OAAR,CAAgBF,KAAhB,CAAL,CAAzB;AAChK;;AAED,SAAStC,aAAT,CAAuB6C,OAAvB,EAAgCC,MAAhC,EAAwCC,QAAxC,EAAkD;AAChDhD,EAAAA,MAAM,GAAGA,MAAM,IAAIG,OAAO,CAAC,kBAAD,CAA1B;AACA2C,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAFgD,CAEvB;AACzB;AACA;AACA;AACA;;AAEA,MAAI,OAAOE,QAAP,KAAoB,SAAxB,EAAmCA,QAAQ,GAAGD,MAAM,YAAY/C,MAA7B,CARa,CAQwB;AACxE;;AAEA,OAAKiD,UAAL,GAAkB,CAAC,CAACH,OAAO,CAACG,UAA5B;AACA,MAAID,QAAJ,EAAc,KAAKC,UAAL,GAAkB,KAAKA,UAAL,IAAmB,CAAC,CAACH,OAAO,CAACI,kBAA/C,CAZkC,CAYiC;AACjF;;AAEA,OAAKC,aAAL,GAAqBxB,gBAAgB,CAAC,IAAD,EAAOmB,OAAP,EAAgB,uBAAhB,EAAyCE,QAAzC,CAArC,CAfgD,CAeyC;AACzF;AACA;;AAEA,OAAKI,MAAL,GAAc,IAAI5B,UAAJ,EAAd;AACA,OAAKf,MAAL,GAAc,CAAd;AACA,OAAK4C,KAAL,GAAa,IAAb;AACA,OAAKC,UAAL,GAAkB,CAAlB;AACA,OAAKC,OAAL,GAAe,IAAf;AACA,OAAKC,KAAL,GAAa,KAAb;AACA,OAAKC,UAAL,GAAkB,KAAlB;AACA,OAAKC,OAAL,GAAe,KAAf,CA1BgD,CA0B1B;AACtB;AACA;AACA;;AAEA,OAAKC,IAAL,GAAY,IAAZ,CA/BgD,CA+B9B;AAClB;;AAEA,OAAKC,YAAL,GAAoB,KAApB;AACA,OAAKC,eAAL,GAAuB,KAAvB;AACA,OAAKC,iBAAL,GAAyB,KAAzB;AACA,OAAKC,eAAL,GAAuB,KAAvB;AACA,OAAKC,MAAL,GAAc,IAAd,CAtCgD,CAsC5B;;AAEpB,OAAKC,SAAL,GAAiBnB,OAAO,CAACmB,SAAR,KAAsB,KAAvC,CAxCgD,CAwCF;;AAE9C,OAAKC,WAAL,GAAmB,CAAC,CAACpB,OAAO,CAACoB,WAA7B,CA1CgD,CA0CN;;AAE1C,OAAKC,SAAL,GAAiB,KAAjB,CA5CgD,CA4CxB;AACxB;AACA;;AAEA,OAAKC,eAAL,GAAuBtB,OAAO,CAACsB,eAAR,IAA2B,MAAlD,CAhDgD,CAgDU;;AAE1D,OAAKC,UAAL,GAAkB,CAAlB,CAlDgD,CAkD3B;;AAErB,OAAKC,WAAL,GAAmB,KAAnB;AACA,OAAKC,OAAL,GAAe,IAAf;AACA,OAAKC,QAAL,GAAgB,IAAhB;;AAEA,MAAI1B,OAAO,CAAC0B,QAAZ,EAAsB;AACpB,QAAI,CAACtC,aAAL,EAAoBA,aAAa,GAAG/B,OAAO,CAAC,iBAAD,CAAP,CAA2B+B,aAA3C;AACpB,SAAKqC,OAAL,GAAe,IAAIrC,aAAJ,CAAkBY,OAAO,CAAC0B,QAA1B,CAAf;AACA,SAAKA,QAAL,GAAgB1B,OAAO,CAAC0B,QAAxB;AACD;AACF;;AAED,SAASzE,QAAT,CAAkB+C,OAAlB,EAA2B;AACzB9C,EAAAA,MAAM,GAAGA,MAAM,IAAIG,OAAO,CAAC,kBAAD,CAA1B;AACA,MAAI,EAAE,gBAAgBJ,QAAlB,CAAJ,EAAiC,OAAO,IAAIA,QAAJ,CAAa+C,OAAb,CAAP,CAFR,CAEsC;AAC/D;;AAEA,MAAIE,QAAQ,GAAG,gBAAgBhD,MAA/B;AACA,OAAKyE,cAAL,GAAsB,IAAIxE,aAAJ,CAAkB6C,OAAlB,EAA2B,IAA3B,EAAiCE,QAAjC,CAAtB,CANyB,CAMyC;;AAElE,OAAK0B,QAAL,GAAgB,IAAhB;;AAEA,MAAI5B,OAAJ,EAAa;AACX,QAAI,OAAOA,OAAO,CAAC6B,IAAf,KAAwB,UAA5B,EAAwC,KAAKC,KAAL,GAAa9B,OAAO,CAAC6B,IAArB;AACxC,QAAI,OAAO7B,OAAO,CAAC+B,OAAf,KAA2B,UAA/B,EAA2C,KAAKC,QAAL,GAAgBhC,OAAO,CAAC+B,OAAxB;AAC5C;;AAEDnE,EAAAA,MAAM,CAACqE,IAAP,CAAY,IAAZ;AACD;;AAEDC,MAAM,CAACC,cAAP,CAAsBlF,QAAQ,CAACmF,SAA/B,EAA0C,WAA1C,EAAuD;AACrD;AACA;AACA;AACAC,EAAAA,UAAU,EAAE,KAJyC;AAKrDC,EAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,QAAI,KAAKX,cAAL,KAAwBY,SAA5B,EAAuC;AACrC,aAAO,KAAP;AACD;;AAED,WAAO,KAAKZ,cAAL,CAAoBN,SAA3B;AACD,GAXoD;AAYrDmB,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaC,KAAb,EAAoB;AACvB;AACA;AACA,QAAI,CAAC,KAAKd,cAAV,EAA0B;AACxB;AACD,KALsB,CAKrB;AACF;;;AAGA,SAAKA,cAAL,CAAoBN,SAApB,GAAgCoB,KAAhC;AACD;AAtBoD,CAAvD;AAwBAxF,QAAQ,CAACmF,SAAT,CAAmBL,OAAnB,GAA6BpD,WAAW,CAACoD,OAAzC;AACA9E,QAAQ,CAACmF,SAAT,CAAmBM,UAAnB,GAAgC/D,WAAW,CAACgE,SAA5C;;AAEA1F,QAAQ,CAACmF,SAAT,CAAmBJ,QAAnB,GAA8B,UAAUY,GAAV,EAAeC,EAAf,EAAmB;AAC/CA,EAAAA,EAAE,CAACD,GAAD,CAAF;AACD,CAFD,C,CAEG;AACH;AACA;AACA;;;AAGA3F,QAAQ,CAACmF,SAAT,CAAmBU,IAAnB,GAA0B,UAAU5E,KAAV,EAAiBwD,QAAjB,EAA2B;AACnD,MAAIqB,KAAK,GAAG,KAAKpB,cAAjB;AACA,MAAIqB,cAAJ;;AAEA,MAAI,CAACD,KAAK,CAAC5C,UAAX,EAAuB;AACrB,QAAI,OAAOjC,KAAP,KAAiB,QAArB,EAA+B;AAC7BwD,MAAAA,QAAQ,GAAGA,QAAQ,IAAIqB,KAAK,CAACzB,eAA7B;;AAEA,UAAII,QAAQ,KAAKqB,KAAK,CAACrB,QAAvB,EAAiC;AAC/BxD,QAAAA,KAAK,GAAGL,MAAM,CAACM,IAAP,CAAYD,KAAZ,EAAmBwD,QAAnB,CAAR;AACAA,QAAAA,QAAQ,GAAG,EAAX;AACD;;AAEDsB,MAAAA,cAAc,GAAG,IAAjB;AACD;AACF,GAXD,MAWO;AACLA,IAAAA,cAAc,GAAG,IAAjB;AACD;;AAED,SAAOC,gBAAgB,CAAC,IAAD,EAAO/E,KAAP,EAAcwD,QAAd,EAAwB,KAAxB,EAA+BsB,cAA/B,CAAvB;AACD,CApBD,C,CAoBG;;;AAGH/F,QAAQ,CAACmF,SAAT,CAAmBrC,OAAnB,GAA6B,UAAU7B,KAAV,EAAiB;AAC5C,SAAO+E,gBAAgB,CAAC,IAAD,EAAO/E,KAAP,EAAc,IAAd,EAAoB,IAApB,EAA0B,KAA1B,CAAvB;AACD,CAFD;;AAIA,SAAS+E,gBAAT,CAA0BhD,MAA1B,EAAkC/B,KAAlC,EAAyCwD,QAAzC,EAAmDwB,UAAnD,EAA+DF,cAA/D,EAA+E;AAC7ExE,EAAAA,KAAK,CAAC,kBAAD,EAAqBN,KAArB,CAAL;AACA,MAAI6E,KAAK,GAAG9C,MAAM,CAAC0B,cAAnB;;AAEA,MAAIzD,KAAK,KAAK,IAAd,EAAoB;AAClB6E,IAAAA,KAAK,CAACnC,OAAN,GAAgB,KAAhB;AACAuC,IAAAA,UAAU,CAAClD,MAAD,EAAS8C,KAAT,CAAV;AACD,GAHD,MAGO;AACL,QAAIK,EAAJ;AACA,QAAI,CAACJ,cAAL,EAAqBI,EAAE,GAAGC,YAAY,CAACN,KAAD,EAAQ7E,KAAR,CAAjB;;AAErB,QAAIkF,EAAJ,EAAQ;AACN9D,MAAAA,cAAc,CAACW,MAAD,EAASmD,EAAT,CAAd;AACD,KAFD,MAEO,IAAIL,KAAK,CAAC5C,UAAN,IAAoBjC,KAAK,IAAIA,KAAK,CAACP,MAAN,GAAe,CAAhD,EAAmD;AACxD,UAAI,OAAOO,KAAP,KAAiB,QAAjB,IAA6B,CAAC6E,KAAK,CAAC5C,UAApC,IAAkD+B,MAAM,CAACoB,cAAP,CAAsBpF,KAAtB,MAAiCL,MAAM,CAACuE,SAA9F,EAAyG;AACvGlE,QAAAA,KAAK,GAAGD,mBAAmB,CAACC,KAAD,CAA3B;AACD;;AAED,UAAIgF,UAAJ,EAAgB;AACd,YAAIH,KAAK,CAACpC,UAAV,EAAsBrB,cAAc,CAACW,MAAD,EAAS,IAAId,kCAAJ,EAAT,CAAd,CAAtB,KAA4FoE,QAAQ,CAACtD,MAAD,EAAS8C,KAAT,EAAgB7E,KAAhB,EAAuB,IAAvB,CAAR;AAC7F,OAFD,MAEO,IAAI6E,KAAK,CAACrC,KAAV,EAAiB;AACtBpB,QAAAA,cAAc,CAACW,MAAD,EAAS,IAAIhB,yBAAJ,EAAT,CAAd;AACD,OAFM,MAEA,IAAI8D,KAAK,CAAC1B,SAAV,EAAqB;AAC1B,eAAO,KAAP;AACD,OAFM,MAEA;AACL0B,QAAAA,KAAK,CAACnC,OAAN,GAAgB,KAAhB;;AAEA,YAAImC,KAAK,CAACtB,OAAN,IAAiB,CAACC,QAAtB,EAAgC;AAC9BxD,UAAAA,KAAK,GAAG6E,KAAK,CAACtB,OAAN,CAAc+B,KAAd,CAAoBtF,KAApB,CAAR;AACA,cAAI6E,KAAK,CAAC5C,UAAN,IAAoBjC,KAAK,CAACP,MAAN,KAAiB,CAAzC,EAA4C4F,QAAQ,CAACtD,MAAD,EAAS8C,KAAT,EAAgB7E,KAAhB,EAAuB,KAAvB,CAAR,CAA5C,KAAuFuF,aAAa,CAACxD,MAAD,EAAS8C,KAAT,CAAb;AACxF,SAHD,MAGO;AACLQ,UAAAA,QAAQ,CAACtD,MAAD,EAAS8C,KAAT,EAAgB7E,KAAhB,EAAuB,KAAvB,CAAR;AACD;AACF;AACF,KArBM,MAqBA,IAAI,CAACgF,UAAL,EAAiB;AACtBH,MAAAA,KAAK,CAACnC,OAAN,GAAgB,KAAhB;AACA6C,MAAAA,aAAa,CAACxD,MAAD,EAAS8C,KAAT,CAAb;AACD;AACF,GAtC4E,CAsC3E;AACF;AACA;;;AAGA,SAAO,CAACA,KAAK,CAACrC,KAAP,KAAiBqC,KAAK,CAACpF,MAAN,GAAeoF,KAAK,CAAC1C,aAArB,IAAsC0C,KAAK,CAACpF,MAAN,KAAiB,CAAxE,CAAP;AACD;;AAED,SAAS4F,QAAT,CAAkBtD,MAAlB,EAA0B8C,KAA1B,EAAiC7E,KAAjC,EAAwCgF,UAAxC,EAAoD;AAClD,MAAIH,KAAK,CAACtC,OAAN,IAAiBsC,KAAK,CAACpF,MAAN,KAAiB,CAAlC,IAAuC,CAACoF,KAAK,CAAClC,IAAlD,EAAwD;AACtDkC,IAAAA,KAAK,CAACxB,UAAN,GAAmB,CAAnB;AACAtB,IAAAA,MAAM,CAACyD,IAAP,CAAY,MAAZ,EAAoBxF,KAApB;AACD,GAHD,MAGO;AACL;AACA6E,IAAAA,KAAK,CAACpF,MAAN,IAAgBoF,KAAK,CAAC5C,UAAN,GAAmB,CAAnB,GAAuBjC,KAAK,CAACP,MAA7C;AACA,QAAIuF,UAAJ,EAAgBH,KAAK,CAACzC,MAAN,CAAaP,OAAb,CAAqB7B,KAArB,EAAhB,KAAiD6E,KAAK,CAACzC,MAAN,CAAawC,IAAb,CAAkB5E,KAAlB;AACjD,QAAI6E,KAAK,CAACjC,YAAV,EAAwB6C,YAAY,CAAC1D,MAAD,CAAZ;AACzB;;AAEDwD,EAAAA,aAAa,CAACxD,MAAD,EAAS8C,KAAT,CAAb;AACD;;AAED,SAASM,YAAT,CAAsBN,KAAtB,EAA6B7E,KAA7B,EAAoC;AAClC,MAAIkF,EAAJ;;AAEA,MAAI,CAAChF,aAAa,CAACF,KAAD,CAAd,IAAyB,OAAOA,KAAP,KAAiB,QAA1C,IAAsDA,KAAK,KAAKqE,SAAhE,IAA6E,CAACQ,KAAK,CAAC5C,UAAxF,EAAoG;AAClGiD,IAAAA,EAAE,GAAG,IAAIpE,oBAAJ,CAAyB,OAAzB,EAAkC,CAAC,QAAD,EAAW,QAAX,EAAqB,YAArB,CAAlC,EAAsEd,KAAtE,CAAL;AACD;;AAED,SAAOkF,EAAP;AACD;;AAEDnG,QAAQ,CAACmF,SAAT,CAAmBwB,QAAnB,GAA8B,YAAY;AACxC,SAAO,KAAKjC,cAAL,CAAoBlB,OAApB,KAAgC,KAAvC;AACD,CAFD,C,CAEG;;;AAGHxD,QAAQ,CAACmF,SAAT,CAAmByB,WAAnB,GAAiC,UAAUC,GAAV,EAAe;AAC9C,MAAI,CAAC1E,aAAL,EAAoBA,aAAa,GAAG/B,OAAO,CAAC,iBAAD,CAAP,CAA2B+B,aAA3C;AACpB,MAAIqC,OAAO,GAAG,IAAIrC,aAAJ,CAAkB0E,GAAlB,CAAd;AACA,OAAKnC,cAAL,CAAoBF,OAApB,GAA8BA,OAA9B,CAH8C,CAGP;;AAEvC,OAAKE,cAAL,CAAoBD,QAApB,GAA+B,KAAKC,cAAL,CAAoBF,OAApB,CAA4BC,QAA3D,CAL8C,CAKuB;;AAErE,MAAIqC,CAAC,GAAG,KAAKpC,cAAL,CAAoBrB,MAApB,CAA2B0D,IAAnC;AACA,MAAIC,OAAO,GAAG,EAAd;;AAEA,SAAOF,CAAC,KAAK,IAAb,EAAmB;AACjBE,IAAAA,OAAO,IAAIxC,OAAO,CAAC+B,KAAR,CAAcO,CAAC,CAACG,IAAhB,CAAX;AACAH,IAAAA,CAAC,GAAGA,CAAC,CAACI,IAAN;AACD;;AAED,OAAKxC,cAAL,CAAoBrB,MAApB,CAA2B8D,KAA3B;;AAEA,MAAIH,OAAO,KAAK,EAAhB,EAAoB,KAAKtC,cAAL,CAAoBrB,MAApB,CAA2BwC,IAA3B,CAAgCmB,OAAhC;AACpB,OAAKtC,cAAL,CAAoBhE,MAApB,GAA6BsG,OAAO,CAACtG,MAArC;AACA,SAAO,IAAP;AACD,CApBD,C,CAoBG;;;AAGH,IAAI0G,OAAO,GAAG,UAAd;;AAEA,SAASC,uBAAT,CAAiCC,CAAjC,EAAoC;AAClC,MAAIA,CAAC,IAAIF,OAAT,EAAkB;AAChB;AACAE,IAAAA,CAAC,GAAGF,OAAJ;AACD,GAHD,MAGO;AACL;AACA;AACAE,IAAAA,CAAC;AACDA,IAAAA,CAAC,IAAIA,CAAC,KAAK,CAAX;AACAA,IAAAA,CAAC,IAAIA,CAAC,KAAK,CAAX;AACAA,IAAAA,CAAC,IAAIA,CAAC,KAAK,CAAX;AACAA,IAAAA,CAAC,IAAIA,CAAC,KAAK,CAAX;AACAA,IAAAA,CAAC,IAAIA,CAAC,KAAK,EAAX;AACAA,IAAAA,CAAC;AACF;;AAED,SAAOA,CAAP;AACD,C,CAAC;AACF;;;AAGA,SAASC,aAAT,CAAuBD,CAAvB,EAA0BxB,KAA1B,EAAiC;AAC/B,MAAIwB,CAAC,IAAI,CAAL,IAAUxB,KAAK,CAACpF,MAAN,KAAiB,CAAjB,IAAsBoF,KAAK,CAACrC,KAA1C,EAAiD,OAAO,CAAP;AACjD,MAAIqC,KAAK,CAAC5C,UAAV,EAAsB,OAAO,CAAP;;AAEtB,MAAIoE,CAAC,KAAKA,CAAV,EAAa;AACX;AACA,QAAIxB,KAAK,CAACtC,OAAN,IAAiBsC,KAAK,CAACpF,MAA3B,EAAmC,OAAOoF,KAAK,CAACzC,MAAN,CAAa0D,IAAb,CAAkBE,IAAlB,CAAuBvG,MAA9B,CAAnC,KAA6E,OAAOoF,KAAK,CAACpF,MAAb;AAC9E,GAP8B,CAO7B;;;AAGF,MAAI4G,CAAC,GAAGxB,KAAK,CAAC1C,aAAd,EAA6B0C,KAAK,CAAC1C,aAAN,GAAsBiE,uBAAuB,CAACC,CAAD,CAA7C;AAC7B,MAAIA,CAAC,IAAIxB,KAAK,CAACpF,MAAf,EAAuB,OAAO4G,CAAP,CAXQ,CAWE;;AAEjC,MAAI,CAACxB,KAAK,CAACrC,KAAX,EAAkB;AAChBqC,IAAAA,KAAK,CAACjC,YAAN,GAAqB,IAArB;AACA,WAAO,CAAP;AACD;;AAED,SAAOiC,KAAK,CAACpF,MAAb;AACD,C,CAAC;;;AAGFV,QAAQ,CAACmF,SAAT,CAAmBP,IAAnB,GAA0B,UAAU0C,CAAV,EAAa;AACrC/F,EAAAA,KAAK,CAAC,MAAD,EAAS+F,CAAT,CAAL;AACAA,EAAAA,CAAC,GAAGE,QAAQ,CAACF,CAAD,EAAI,EAAJ,CAAZ;AACA,MAAIxB,KAAK,GAAG,KAAKpB,cAAjB;AACA,MAAI+C,KAAK,GAAGH,CAAZ;AACA,MAAIA,CAAC,KAAK,CAAV,EAAaxB,KAAK,CAAChC,eAAN,GAAwB,KAAxB,CALwB,CAKO;AAC5C;AACA;;AAEA,MAAIwD,CAAC,KAAK,CAAN,IAAWxB,KAAK,CAACjC,YAAjB,KAAkC,CAACiC,KAAK,CAAC1C,aAAN,KAAwB,CAAxB,GAA4B0C,KAAK,CAACpF,MAAN,IAAgBoF,KAAK,CAAC1C,aAAlD,GAAkE0C,KAAK,CAACpF,MAAN,GAAe,CAAlF,KAAwFoF,KAAK,CAACrC,KAAhI,CAAJ,EAA4I;AAC1IlC,IAAAA,KAAK,CAAC,oBAAD,EAAuBuE,KAAK,CAACpF,MAA7B,EAAqCoF,KAAK,CAACrC,KAA3C,CAAL;AACA,QAAIqC,KAAK,CAACpF,MAAN,KAAiB,CAAjB,IAAsBoF,KAAK,CAACrC,KAAhC,EAAuCiE,WAAW,CAAC,IAAD,CAAX,CAAvC,KAA8DhB,YAAY,CAAC,IAAD,CAAZ;AAC9D,WAAO,IAAP;AACD;;AAEDY,EAAAA,CAAC,GAAGC,aAAa,CAACD,CAAD,EAAIxB,KAAJ,CAAjB,CAfqC,CAeR;;AAE7B,MAAIwB,CAAC,KAAK,CAAN,IAAWxB,KAAK,CAACrC,KAArB,EAA4B;AAC1B,QAAIqC,KAAK,CAACpF,MAAN,KAAiB,CAArB,EAAwBgH,WAAW,CAAC,IAAD,CAAX;AACxB,WAAO,IAAP;AACD,GApBoC,CAoBnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAIC,MAAM,GAAG7B,KAAK,CAACjC,YAAnB;AACAtC,EAAAA,KAAK,CAAC,eAAD,EAAkBoG,MAAlB,CAAL,CA7CqC,CA6CL;;AAEhC,MAAI7B,KAAK,CAACpF,MAAN,KAAiB,CAAjB,IAAsBoF,KAAK,CAACpF,MAAN,GAAe4G,CAAf,GAAmBxB,KAAK,CAAC1C,aAAnD,EAAkE;AAChEuE,IAAAA,MAAM,GAAG,IAAT;AACApG,IAAAA,KAAK,CAAC,4BAAD,EAA+BoG,MAA/B,CAAL;AACD,GAlDoC,CAkDnC;AACF;;;AAGA,MAAI7B,KAAK,CAACrC,KAAN,IAAeqC,KAAK,CAACnC,OAAzB,EAAkC;AAChCgE,IAAAA,MAAM,GAAG,KAAT;AACApG,IAAAA,KAAK,CAAC,kBAAD,EAAqBoG,MAArB,CAAL;AACD,GAHD,MAGO,IAAIA,MAAJ,EAAY;AACjBpG,IAAAA,KAAK,CAAC,SAAD,CAAL;AACAuE,IAAAA,KAAK,CAACnC,OAAN,GAAgB,IAAhB;AACAmC,IAAAA,KAAK,CAAClC,IAAN,GAAa,IAAb,CAHiB,CAGE;;AAEnB,QAAIkC,KAAK,CAACpF,MAAN,KAAiB,CAArB,EAAwBoF,KAAK,CAACjC,YAAN,GAAqB,IAArB,CALP,CAKkC;;AAEnD,SAAKgB,KAAL,CAAWiB,KAAK,CAAC1C,aAAjB;;AAEA0C,IAAAA,KAAK,CAAClC,IAAN,GAAa,KAAb,CATiB,CASG;AACpB;;AAEA,QAAI,CAACkC,KAAK,CAACnC,OAAX,EAAoB2D,CAAC,GAAGC,aAAa,CAACE,KAAD,EAAQ3B,KAAR,CAAjB;AACrB;;AAED,MAAI8B,GAAJ;AACA,MAAIN,CAAC,GAAG,CAAR,EAAWM,GAAG,GAAGC,QAAQ,CAACP,CAAD,EAAIxB,KAAJ,CAAd,CAAX,KAAyC8B,GAAG,GAAG,IAAN;;AAEzC,MAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB9B,IAAAA,KAAK,CAACjC,YAAN,GAAqBiC,KAAK,CAACpF,MAAN,IAAgBoF,KAAK,CAAC1C,aAA3C;AACAkE,IAAAA,CAAC,GAAG,CAAJ;AACD,GAHD,MAGO;AACLxB,IAAAA,KAAK,CAACpF,MAAN,IAAgB4G,CAAhB;AACAxB,IAAAA,KAAK,CAACxB,UAAN,GAAmB,CAAnB;AACD;;AAED,MAAIwB,KAAK,CAACpF,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACA;AACA,QAAI,CAACoF,KAAK,CAACrC,KAAX,EAAkBqC,KAAK,CAACjC,YAAN,GAAqB,IAArB,CAHI,CAGuB;;AAE7C,QAAI4D,KAAK,KAAKH,CAAV,IAAexB,KAAK,CAACrC,KAAzB,EAAgCiE,WAAW,CAAC,IAAD,CAAX;AACjC;;AAED,MAAIE,GAAG,KAAK,IAAZ,EAAkB,KAAKnB,IAAL,CAAU,MAAV,EAAkBmB,GAAlB;AAClB,SAAOA,GAAP;AACD,CA7FD;;AA+FA,SAAS1B,UAAT,CAAoBlD,MAApB,EAA4B8C,KAA5B,EAAmC;AACjCvE,EAAAA,KAAK,CAAC,YAAD,CAAL;AACA,MAAIuE,KAAK,CAACrC,KAAV,EAAiB;;AAEjB,MAAIqC,KAAK,CAACtB,OAAV,EAAmB;AACjB,QAAIvD,KAAK,GAAG6E,KAAK,CAACtB,OAAN,CAAcsD,GAAd,EAAZ;;AAEA,QAAI7G,KAAK,IAAIA,KAAK,CAACP,MAAnB,EAA2B;AACzBoF,MAAAA,KAAK,CAACzC,MAAN,CAAawC,IAAb,CAAkB5E,KAAlB;AACA6E,MAAAA,KAAK,CAACpF,MAAN,IAAgBoF,KAAK,CAAC5C,UAAN,GAAmB,CAAnB,GAAuBjC,KAAK,CAACP,MAA7C;AACD;AACF;;AAEDoF,EAAAA,KAAK,CAACrC,KAAN,GAAc,IAAd;;AAEA,MAAIqC,KAAK,CAAClC,IAAV,EAAgB;AACd;AACA;AACA;AACA8C,IAAAA,YAAY,CAAC1D,MAAD,CAAZ;AACD,GALD,MAKO;AACL;AACA8C,IAAAA,KAAK,CAACjC,YAAN,GAAqB,KAArB;;AAEA,QAAI,CAACiC,KAAK,CAAChC,eAAX,EAA4B;AAC1BgC,MAAAA,KAAK,CAAChC,eAAN,GAAwB,IAAxB;AACAiE,MAAAA,aAAa,CAAC/E,MAAD,CAAb;AACD;AACF;AACF,C,CAAC;AACF;AACA;;;AAGA,SAAS0D,YAAT,CAAsB1D,MAAtB,EAA8B;AAC5B,MAAI8C,KAAK,GAAG9C,MAAM,CAAC0B,cAAnB;AACAnD,EAAAA,KAAK,CAAC,cAAD,EAAiBuE,KAAK,CAACjC,YAAvB,EAAqCiC,KAAK,CAAChC,eAA3C,CAAL;AACAgC,EAAAA,KAAK,CAACjC,YAAN,GAAqB,KAArB;;AAEA,MAAI,CAACiC,KAAK,CAAChC,eAAX,EAA4B;AAC1BvC,IAAAA,KAAK,CAAC,cAAD,EAAiBuE,KAAK,CAACtC,OAAvB,CAAL;AACAsC,IAAAA,KAAK,CAAChC,eAAN,GAAwB,IAAxB;AACAkE,IAAAA,OAAO,CAACC,QAAR,CAAiBF,aAAjB,EAAgC/E,MAAhC;AACD;AACF;;AAED,SAAS+E,aAAT,CAAuB/E,MAAvB,EAA+B;AAC7B,MAAI8C,KAAK,GAAG9C,MAAM,CAAC0B,cAAnB;AACAnD,EAAAA,KAAK,CAAC,eAAD,EAAkBuE,KAAK,CAAC1B,SAAxB,EAAmC0B,KAAK,CAACpF,MAAzC,EAAiDoF,KAAK,CAACrC,KAAvD,CAAL;;AAEA,MAAI,CAACqC,KAAK,CAAC1B,SAAP,KAAqB0B,KAAK,CAACpF,MAAN,IAAgBoF,KAAK,CAACrC,KAA3C,CAAJ,EAAuD;AACrDT,IAAAA,MAAM,CAACyD,IAAP,CAAY,UAAZ;AACAX,IAAAA,KAAK,CAAChC,eAAN,GAAwB,KAAxB;AACD,GAP4B,CAO3B;AACF;AACA;AACA;AACA;AACA;;;AAGAgC,EAAAA,KAAK,CAACjC,YAAN,GAAqB,CAACiC,KAAK,CAACtC,OAAP,IAAkB,CAACsC,KAAK,CAACrC,KAAzB,IAAkCqC,KAAK,CAACpF,MAAN,IAAgBoF,KAAK,CAAC1C,aAA7E;AACA8E,EAAAA,IAAI,CAAClF,MAAD,CAAJ;AACD,C,CAAC;AACF;AACA;AACA;AACA;AACA;;;AAGA,SAASwD,aAAT,CAAuBxD,MAAvB,EAA+B8C,KAA/B,EAAsC;AACpC,MAAI,CAACA,KAAK,CAACvB,WAAX,EAAwB;AACtBuB,IAAAA,KAAK,CAACvB,WAAN,GAAoB,IAApB;AACAyD,IAAAA,OAAO,CAACC,QAAR,CAAiBE,cAAjB,EAAiCnF,MAAjC,EAAyC8C,KAAzC;AACD;AACF;;AAED,SAASqC,cAAT,CAAwBnF,MAAxB,EAAgC8C,KAAhC,EAAuC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAO,CAACA,KAAK,CAACnC,OAAP,IAAkB,CAACmC,KAAK,CAACrC,KAAzB,KAAmCqC,KAAK,CAACpF,MAAN,GAAeoF,KAAK,CAAC1C,aAArB,IAAsC0C,KAAK,CAACtC,OAAN,IAAiBsC,KAAK,CAACpF,MAAN,KAAiB,CAA3G,CAAP,EAAsH;AACpH,QAAI0H,GAAG,GAAGtC,KAAK,CAACpF,MAAhB;AACAa,IAAAA,KAAK,CAAC,sBAAD,CAAL;AACAyB,IAAAA,MAAM,CAAC4B,IAAP,CAAY,CAAZ;AACA,QAAIwD,GAAG,KAAKtC,KAAK,CAACpF,MAAlB,EAA0B;AACxB;AACH;;AAEDoF,EAAAA,KAAK,CAACvB,WAAN,GAAoB,KAApB;AACD,C,CAAC;AACF;AACA;AACA;;;AAGAvE,QAAQ,CAACmF,SAAT,CAAmBN,KAAnB,GAA2B,UAAUyC,CAAV,EAAa;AACtCjF,EAAAA,cAAc,CAAC,IAAD,EAAO,IAAIJ,0BAAJ,CAA+B,SAA/B,CAAP,CAAd;AACD,CAFD;;AAIAjC,QAAQ,CAACmF,SAAT,CAAmBkD,IAAnB,GAA0B,UAAUC,IAAV,EAAgBC,QAAhB,EAA0B;AAClD,MAAIC,GAAG,GAAG,IAAV;AACA,MAAI1C,KAAK,GAAG,KAAKpB,cAAjB;;AAEA,UAAQoB,KAAK,CAACvC,UAAd;AACE,SAAK,CAAL;AACEuC,MAAAA,KAAK,CAACxC,KAAN,GAAcgF,IAAd;AACA;;AAEF,SAAK,CAAL;AACExC,MAAAA,KAAK,CAACxC,KAAN,GAAc,CAACwC,KAAK,CAACxC,KAAP,EAAcgF,IAAd,CAAd;AACA;;AAEF;AACExC,MAAAA,KAAK,CAACxC,KAAN,CAAYuC,IAAZ,CAAiByC,IAAjB;AACA;AAXJ;;AAcAxC,EAAAA,KAAK,CAACvC,UAAN,IAAoB,CAApB;AACAhC,EAAAA,KAAK,CAAC,uBAAD,EAA0BuE,KAAK,CAACvC,UAAhC,EAA4CgF,QAA5C,CAAL;AACA,MAAIE,KAAK,GAAG,CAAC,CAACF,QAAD,IAAaA,QAAQ,CAACT,GAAT,KAAiB,KAA/B,KAAyCQ,IAAI,KAAKN,OAAO,CAACU,MAA1D,IAAoEJ,IAAI,KAAKN,OAAO,CAACW,MAAjG;AACA,MAAIC,KAAK,GAAGH,KAAK,GAAGI,KAAH,GAAWC,MAA5B;AACA,MAAIhD,KAAK,CAACpC,UAAV,EAAsBsE,OAAO,CAACC,QAAR,CAAiBW,KAAjB,EAAtB,KAAmDJ,GAAG,CAACO,IAAJ,CAAS,KAAT,EAAgBH,KAAhB;AACnDN,EAAAA,IAAI,CAAC3F,EAAL,CAAQ,QAAR,EAAkBqG,QAAlB;;AAEA,WAASA,QAAT,CAAkBrE,QAAlB,EAA4BsE,UAA5B,EAAwC;AACtC1H,IAAAA,KAAK,CAAC,UAAD,CAAL;;AAEA,QAAIoD,QAAQ,KAAK6D,GAAjB,EAAsB;AACpB,UAAIS,UAAU,IAAIA,UAAU,CAACC,UAAX,KAA0B,KAA5C,EAAmD;AACjDD,QAAAA,UAAU,CAACC,UAAX,GAAwB,IAAxB;AACAC,QAAAA,OAAO;AACR;AACF;AACF;;AAED,WAASN,KAAT,GAAiB;AACftH,IAAAA,KAAK,CAAC,OAAD,CAAL;AACA+G,IAAAA,IAAI,CAACR,GAAL;AACD,GAvCiD,CAuChD;AACF;AACA;AACA;;;AAGA,MAAIsB,OAAO,GAAGC,WAAW,CAACb,GAAD,CAAzB;AACAF,EAAAA,IAAI,CAAC3F,EAAL,CAAQ,OAAR,EAAiByG,OAAjB;AACA,MAAIE,SAAS,GAAG,KAAhB;;AAEA,WAASH,OAAT,GAAmB;AACjB5H,IAAAA,KAAK,CAAC,SAAD,CAAL,CADiB,CACC;;AAElB+G,IAAAA,IAAI,CAACiB,cAAL,CAAoB,OAApB,EAA6BC,OAA7B;AACAlB,IAAAA,IAAI,CAACiB,cAAL,CAAoB,QAApB,EAA8BE,QAA9B;AACAnB,IAAAA,IAAI,CAACiB,cAAL,CAAoB,OAApB,EAA6BH,OAA7B;AACAd,IAAAA,IAAI,CAACiB,cAAL,CAAoB,OAApB,EAA6BG,OAA7B;AACApB,IAAAA,IAAI,CAACiB,cAAL,CAAoB,QAApB,EAA8BP,QAA9B;AACAR,IAAAA,GAAG,CAACe,cAAJ,CAAmB,KAAnB,EAA0BV,KAA1B;AACAL,IAAAA,GAAG,CAACe,cAAJ,CAAmB,KAAnB,EAA0BT,MAA1B;AACAN,IAAAA,GAAG,CAACe,cAAJ,CAAmB,MAAnB,EAA2BI,MAA3B;AACAL,IAAAA,SAAS,GAAG,IAAZ,CAXiB,CAWC;AAClB;AACA;AACA;AACA;;AAEA,QAAIxD,KAAK,CAACxB,UAAN,KAAqB,CAACgE,IAAI,CAACsB,cAAN,IAAwBtB,IAAI,CAACsB,cAAL,CAAoBC,SAAjE,CAAJ,EAAiFT,OAAO;AACzF;;AAEDZ,EAAAA,GAAG,CAAC7F,EAAJ,CAAO,MAAP,EAAegH,MAAf;;AAEA,WAASA,MAAT,CAAgB1I,KAAhB,EAAuB;AACrBM,IAAAA,KAAK,CAAC,QAAD,CAAL;AACA,QAAIqG,GAAG,GAAGU,IAAI,CAAC/B,KAAL,CAAWtF,KAAX,CAAV;AACAM,IAAAA,KAAK,CAAC,YAAD,EAAeqG,GAAf,CAAL;;AAEA,QAAIA,GAAG,KAAK,KAAZ,EAAmB;AACjB;AACA;AACA;AACA;AACA,UAAI,CAAC9B,KAAK,CAACvC,UAAN,KAAqB,CAArB,IAA0BuC,KAAK,CAACxC,KAAN,KAAgBgF,IAA1C,IAAkDxC,KAAK,CAACvC,UAAN,GAAmB,CAAnB,IAAwBuG,OAAO,CAAChE,KAAK,CAACxC,KAAP,EAAcgF,IAAd,CAAP,KAA+B,CAAC,CAA3G,KAAiH,CAACgB,SAAtH,EAAiI;AAC/H/H,QAAAA,KAAK,CAAC,6BAAD,EAAgCuE,KAAK,CAACxB,UAAtC,CAAL;AACAwB,QAAAA,KAAK,CAACxB,UAAN;AACD;;AAEDkE,MAAAA,GAAG,CAACuB,KAAJ;AACD;AACF,GAxFiD,CAwFhD;AACF;;;AAGA,WAASL,OAAT,CAAiBvD,EAAjB,EAAqB;AACnB5E,IAAAA,KAAK,CAAC,SAAD,EAAY4E,EAAZ,CAAL;AACA2C,IAAAA,MAAM;AACNR,IAAAA,IAAI,CAACiB,cAAL,CAAoB,OAApB,EAA6BG,OAA7B;AACA,QAAIpJ,eAAe,CAACgI,IAAD,EAAO,OAAP,CAAf,KAAmC,CAAvC,EAA0CjG,cAAc,CAACiG,IAAD,EAAOnC,EAAP,CAAd;AAC3C,GAjGiD,CAiGhD;;;AAGF5D,EAAAA,eAAe,CAAC+F,IAAD,EAAO,OAAP,EAAgBoB,OAAhB,CAAf,CApGkD,CAoGT;;AAEzC,WAASF,OAAT,GAAmB;AACjBlB,IAAAA,IAAI,CAACiB,cAAL,CAAoB,QAApB,EAA8BE,QAA9B;AACAX,IAAAA,MAAM;AACP;;AAEDR,EAAAA,IAAI,CAACS,IAAL,CAAU,OAAV,EAAmBS,OAAnB;;AAEA,WAASC,QAAT,GAAoB;AAClBlI,IAAAA,KAAK,CAAC,UAAD,CAAL;AACA+G,IAAAA,IAAI,CAACiB,cAAL,CAAoB,OAApB,EAA6BC,OAA7B;AACAV,IAAAA,MAAM;AACP;;AAEDR,EAAAA,IAAI,CAACS,IAAL,CAAU,QAAV,EAAoBU,QAApB;;AAEA,WAASX,MAAT,GAAkB;AAChBvH,IAAAA,KAAK,CAAC,QAAD,CAAL;AACAiH,IAAAA,GAAG,CAACM,MAAJ,CAAWR,IAAX;AACD,GAxHiD,CAwHhD;;;AAGFA,EAAAA,IAAI,CAAC7B,IAAL,CAAU,MAAV,EAAkB+B,GAAlB,EA3HkD,CA2H1B;;AAExB,MAAI,CAAC1C,KAAK,CAACtC,OAAX,EAAoB;AAClBjC,IAAAA,KAAK,CAAC,aAAD,CAAL;AACAiH,IAAAA,GAAG,CAACwB,MAAJ;AACD;;AAED,SAAO1B,IAAP;AACD,CAnID;;AAqIA,SAASe,WAAT,CAAqBb,GAArB,EAA0B;AACxB,SAAO,SAASyB,yBAAT,GAAqC;AAC1C,QAAInE,KAAK,GAAG0C,GAAG,CAAC9D,cAAhB;AACAnD,IAAAA,KAAK,CAAC,aAAD,EAAgBuE,KAAK,CAACxB,UAAtB,CAAL;AACA,QAAIwB,KAAK,CAACxB,UAAV,EAAsBwB,KAAK,CAACxB,UAAN;;AAEtB,QAAIwB,KAAK,CAACxB,UAAN,KAAqB,CAArB,IAA0BhE,eAAe,CAACkI,GAAD,EAAM,MAAN,CAA7C,EAA4D;AAC1D1C,MAAAA,KAAK,CAACtC,OAAN,GAAgB,IAAhB;AACA0E,MAAAA,IAAI,CAACM,GAAD,CAAJ;AACD;AACF,GATD;AAUD;;AAEDxI,QAAQ,CAACmF,SAAT,CAAmB2D,MAAnB,GAA4B,UAAUR,IAAV,EAAgB;AAC1C,MAAIxC,KAAK,GAAG,KAAKpB,cAAjB;AACA,MAAIuE,UAAU,GAAG;AACfC,IAAAA,UAAU,EAAE;AADG,GAAjB,CAF0C,CAIvC;;AAEH,MAAIpD,KAAK,CAACvC,UAAN,KAAqB,CAAzB,EAA4B,OAAO,IAAP,CANc,CAMD;;AAEzC,MAAIuC,KAAK,CAACvC,UAAN,KAAqB,CAAzB,EAA4B;AAC1B;AACA,QAAI+E,IAAI,IAAIA,IAAI,KAAKxC,KAAK,CAACxC,KAA3B,EAAkC,OAAO,IAAP;AAClC,QAAI,CAACgF,IAAL,EAAWA,IAAI,GAAGxC,KAAK,CAACxC,KAAb,CAHe,CAGK;;AAE/BwC,IAAAA,KAAK,CAACxC,KAAN,GAAc,IAAd;AACAwC,IAAAA,KAAK,CAACvC,UAAN,GAAmB,CAAnB;AACAuC,IAAAA,KAAK,CAACtC,OAAN,GAAgB,KAAhB;AACA,QAAI8E,IAAJ,EAAUA,IAAI,CAAC7B,IAAL,CAAU,QAAV,EAAoB,IAApB,EAA0BwC,UAA1B;AACV,WAAO,IAAP;AACD,GAlByC,CAkBxC;;;AAGF,MAAI,CAACX,IAAL,EAAW;AACT;AACA,QAAI4B,KAAK,GAAGpE,KAAK,CAACxC,KAAlB;AACA,QAAI8E,GAAG,GAAGtC,KAAK,CAACvC,UAAhB;AACAuC,IAAAA,KAAK,CAACxC,KAAN,GAAc,IAAd;AACAwC,IAAAA,KAAK,CAACvC,UAAN,GAAmB,CAAnB;AACAuC,IAAAA,KAAK,CAACtC,OAAN,GAAgB,KAAhB;;AAEA,SAAK,IAAI2G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,GAApB,EAAyB+B,CAAC,EAA1B,EAA8B;AAC5BD,MAAAA,KAAK,CAACC,CAAD,CAAL,CAAS1D,IAAT,CAAc,QAAd,EAAwB,IAAxB,EAA8B;AAC5ByC,QAAAA,UAAU,EAAE;AADgB,OAA9B;AAGD;;AAED,WAAO,IAAP;AACD,GApCyC,CAoCxC;;;AAGF,MAAIkB,KAAK,GAAGN,OAAO,CAAChE,KAAK,CAACxC,KAAP,EAAcgF,IAAd,CAAnB;AACA,MAAI8B,KAAK,KAAK,CAAC,CAAf,EAAkB,OAAO,IAAP;AAClBtE,EAAAA,KAAK,CAACxC,KAAN,CAAY+G,MAAZ,CAAmBD,KAAnB,EAA0B,CAA1B;AACAtE,EAAAA,KAAK,CAACvC,UAAN,IAAoB,CAApB;AACA,MAAIuC,KAAK,CAACvC,UAAN,KAAqB,CAAzB,EAA4BuC,KAAK,CAACxC,KAAN,GAAcwC,KAAK,CAACxC,KAAN,CAAY,CAAZ,CAAd;AAC5BgF,EAAAA,IAAI,CAAC7B,IAAL,CAAU,QAAV,EAAoB,IAApB,EAA0BwC,UAA1B;AACA,SAAO,IAAP;AACD,CA9CD,C,CA8CG;AACH;;;AAGAjJ,QAAQ,CAACmF,SAAT,CAAmBxC,EAAnB,GAAwB,UAAU2H,EAAV,EAAc7H,EAAd,EAAkB;AACxC,MAAI8H,GAAG,GAAG5J,MAAM,CAACwE,SAAP,CAAiBxC,EAAjB,CAAoBqC,IAApB,CAAyB,IAAzB,EAA+BsF,EAA/B,EAAmC7H,EAAnC,CAAV;AACA,MAAIqD,KAAK,GAAG,KAAKpB,cAAjB;;AAEA,MAAI4F,EAAE,KAAK,MAAX,EAAmB;AACjB;AACA;AACAxE,IAAAA,KAAK,CAAC/B,iBAAN,GAA0B,KAAKyG,aAAL,CAAmB,UAAnB,IAAiC,CAA3D,CAHiB,CAG6C;;AAE9D,QAAI1E,KAAK,CAACtC,OAAN,KAAkB,KAAtB,EAA6B,KAAKwG,MAAL;AAC9B,GAND,MAMO,IAAIM,EAAE,KAAK,UAAX,EAAuB;AAC5B,QAAI,CAACxE,KAAK,CAACpC,UAAP,IAAqB,CAACoC,KAAK,CAAC/B,iBAAhC,EAAmD;AACjD+B,MAAAA,KAAK,CAAC/B,iBAAN,GAA0B+B,KAAK,CAACjC,YAAN,GAAqB,IAA/C;AACAiC,MAAAA,KAAK,CAACtC,OAAN,GAAgB,KAAhB;AACAsC,MAAAA,KAAK,CAAChC,eAAN,GAAwB,KAAxB;AACAvC,MAAAA,KAAK,CAAC,aAAD,EAAgBuE,KAAK,CAACpF,MAAtB,EAA8BoF,KAAK,CAACnC,OAApC,CAAL;;AAEA,UAAImC,KAAK,CAACpF,MAAV,EAAkB;AAChBgG,QAAAA,YAAY,CAAC,IAAD,CAAZ;AACD,OAFD,MAEO,IAAI,CAACZ,KAAK,CAACnC,OAAX,EAAoB;AACzBqE,QAAAA,OAAO,CAACC,QAAR,CAAiBwC,gBAAjB,EAAmC,IAAnC;AACD;AACF;AACF;;AAED,SAAOF,GAAP;AACD,CA1BD;;AA4BAvK,QAAQ,CAACmF,SAAT,CAAmBuF,WAAnB,GAAiC1K,QAAQ,CAACmF,SAAT,CAAmBxC,EAApD;;AAEA3C,QAAQ,CAACmF,SAAT,CAAmBoE,cAAnB,GAAoC,UAAUe,EAAV,EAAc7H,EAAd,EAAkB;AACpD,MAAI8H,GAAG,GAAG5J,MAAM,CAACwE,SAAP,CAAiBoE,cAAjB,CAAgCvE,IAAhC,CAAqC,IAArC,EAA2CsF,EAA3C,EAA+C7H,EAA/C,CAAV;;AAEA,MAAI6H,EAAE,KAAK,UAAX,EAAuB;AACrB;AACA;AACA;AACA;AACA;AACA;AACAtC,IAAAA,OAAO,CAACC,QAAR,CAAiB0C,uBAAjB,EAA0C,IAA1C;AACD;;AAED,SAAOJ,GAAP;AACD,CAdD;;AAgBAvK,QAAQ,CAACmF,SAAT,CAAmByF,kBAAnB,GAAwC,UAAUN,EAAV,EAAc;AACpD,MAAIC,GAAG,GAAG5J,MAAM,CAACwE,SAAP,CAAiByF,kBAAjB,CAAoCC,KAApC,CAA0C,IAA1C,EAAgDC,SAAhD,CAAV;;AAEA,MAAIR,EAAE,KAAK,UAAP,IAAqBA,EAAE,KAAKhF,SAAhC,EAA2C;AACzC;AACA;AACA;AACA;AACA;AACA;AACA0C,IAAAA,OAAO,CAACC,QAAR,CAAiB0C,uBAAjB,EAA0C,IAA1C;AACD;;AAED,SAAOJ,GAAP;AACD,CAdD;;AAgBA,SAASI,uBAAT,CAAiCI,IAAjC,EAAuC;AACrC,MAAIjF,KAAK,GAAGiF,IAAI,CAACrG,cAAjB;AACAoB,EAAAA,KAAK,CAAC/B,iBAAN,GAA0BgH,IAAI,CAACP,aAAL,CAAmB,UAAnB,IAAiC,CAA3D;;AAEA,MAAI1E,KAAK,CAAC9B,eAAN,IAAyB,CAAC8B,KAAK,CAAC7B,MAApC,EAA4C;AAC1C;AACA;AACA6B,IAAAA,KAAK,CAACtC,OAAN,GAAgB,IAAhB,CAH0C,CAGpB;AACvB,GAJD,MAIO,IAAIuH,IAAI,CAACP,aAAL,CAAmB,MAAnB,IAA6B,CAAjC,EAAoC;AACzCO,IAAAA,IAAI,CAACf,MAAL;AACD;AACF;;AAED,SAASS,gBAAT,CAA0BM,IAA1B,EAAgC;AAC9BxJ,EAAAA,KAAK,CAAC,0BAAD,CAAL;AACAwJ,EAAAA,IAAI,CAACnG,IAAL,CAAU,CAAV;AACD,C,CAAC;AACF;;;AAGA5E,QAAQ,CAACmF,SAAT,CAAmB6E,MAAnB,GAA4B,YAAY;AACtC,MAAIlE,KAAK,GAAG,KAAKpB,cAAjB;;AAEA,MAAI,CAACoB,KAAK,CAACtC,OAAX,EAAoB;AAClBjC,IAAAA,KAAK,CAAC,QAAD,CAAL,CADkB,CACD;AACjB;AACA;;AAEAuE,IAAAA,KAAK,CAACtC,OAAN,GAAgB,CAACsC,KAAK,CAAC/B,iBAAvB;AACAiG,IAAAA,MAAM,CAAC,IAAD,EAAOlE,KAAP,CAAN;AACD;;AAEDA,EAAAA,KAAK,CAAC7B,MAAN,GAAe,KAAf;AACA,SAAO,IAAP;AACD,CAdD;;AAgBA,SAAS+F,MAAT,CAAgBhH,MAAhB,EAAwB8C,KAAxB,EAA+B;AAC7B,MAAI,CAACA,KAAK,CAAC9B,eAAX,EAA4B;AAC1B8B,IAAAA,KAAK,CAAC9B,eAAN,GAAwB,IAAxB;AACAgE,IAAAA,OAAO,CAACC,QAAR,CAAiB+C,OAAjB,EAA0BhI,MAA1B,EAAkC8C,KAAlC;AACD;AACF;;AAED,SAASkF,OAAT,CAAiBhI,MAAjB,EAAyB8C,KAAzB,EAAgC;AAC9BvE,EAAAA,KAAK,CAAC,QAAD,EAAWuE,KAAK,CAACnC,OAAjB,CAAL;;AAEA,MAAI,CAACmC,KAAK,CAACnC,OAAX,EAAoB;AAClBX,IAAAA,MAAM,CAAC4B,IAAP,CAAY,CAAZ;AACD;;AAEDkB,EAAAA,KAAK,CAAC9B,eAAN,GAAwB,KAAxB;AACAhB,EAAAA,MAAM,CAACyD,IAAP,CAAY,QAAZ;AACAyB,EAAAA,IAAI,CAAClF,MAAD,CAAJ;AACA,MAAI8C,KAAK,CAACtC,OAAN,IAAiB,CAACsC,KAAK,CAACnC,OAA5B,EAAqCX,MAAM,CAAC4B,IAAP,CAAY,CAAZ;AACtC;;AAED5E,QAAQ,CAACmF,SAAT,CAAmB4E,KAAnB,GAA2B,YAAY;AACrCxI,EAAAA,KAAK,CAAC,uBAAD,EAA0B,KAAKmD,cAAL,CAAoBlB,OAA9C,CAAL;;AAEA,MAAI,KAAKkB,cAAL,CAAoBlB,OAApB,KAAgC,KAApC,EAA2C;AACzCjC,IAAAA,KAAK,CAAC,OAAD,CAAL;AACA,SAAKmD,cAAL,CAAoBlB,OAApB,GAA8B,KAA9B;AACA,SAAKiD,IAAL,CAAU,OAAV;AACD;;AAED,OAAK/B,cAAL,CAAoBT,MAApB,GAA6B,IAA7B;AACA,SAAO,IAAP;AACD,CAXD;;AAaA,SAASiE,IAAT,CAAclF,MAAd,EAAsB;AACpB,MAAI8C,KAAK,GAAG9C,MAAM,CAAC0B,cAAnB;AACAnD,EAAAA,KAAK,CAAC,MAAD,EAASuE,KAAK,CAACtC,OAAf,CAAL;;AAEA,SAAOsC,KAAK,CAACtC,OAAN,IAAiBR,MAAM,CAAC4B,IAAP,OAAkB,IAA1C,EAAgD;AAC9C;AACD;AACF,C,CAAC;AACF;AACA;;;AAGA5E,QAAQ,CAACmF,SAAT,CAAmB8F,IAAnB,GAA0B,UAAUjI,MAAV,EAAkB;AAC1C,MAAIkI,KAAK,GAAG,IAAZ;;AAEA,MAAIpF,KAAK,GAAG,KAAKpB,cAAjB;AACA,MAAIT,MAAM,GAAG,KAAb;AACAjB,EAAAA,MAAM,CAACL,EAAP,CAAU,KAAV,EAAiB,YAAY;AAC3BpB,IAAAA,KAAK,CAAC,aAAD,CAAL;;AAEA,QAAIuE,KAAK,CAACtB,OAAN,IAAiB,CAACsB,KAAK,CAACrC,KAA5B,EAAmC;AACjC,UAAIxC,KAAK,GAAG6E,KAAK,CAACtB,OAAN,CAAcsD,GAAd,EAAZ;AACA,UAAI7G,KAAK,IAAIA,KAAK,CAACP,MAAnB,EAA2BwK,KAAK,CAACrF,IAAN,CAAW5E,KAAX;AAC5B;;AAEDiK,IAAAA,KAAK,CAACrF,IAAN,CAAW,IAAX;AACD,GATD;AAUA7C,EAAAA,MAAM,CAACL,EAAP,CAAU,MAAV,EAAkB,UAAU1B,KAAV,EAAiB;AACjCM,IAAAA,KAAK,CAAC,cAAD,CAAL;AACA,QAAIuE,KAAK,CAACtB,OAAV,EAAmBvD,KAAK,GAAG6E,KAAK,CAACtB,OAAN,CAAc+B,KAAd,CAAoBtF,KAApB,CAAR,CAFc,CAEsB;;AAEvD,QAAI6E,KAAK,CAAC5C,UAAN,KAAqBjC,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKqE,SAAjD,CAAJ,EAAiE,OAAjE,KAA6E,IAAI,CAACQ,KAAK,CAAC5C,UAAP,KAAsB,CAACjC,KAAD,IAAU,CAACA,KAAK,CAACP,MAAvC,CAAJ,EAAoD;;AAEjI,QAAIkH,GAAG,GAAGsD,KAAK,CAACrF,IAAN,CAAW5E,KAAX,CAAV;;AAEA,QAAI,CAAC2G,GAAL,EAAU;AACR3D,MAAAA,MAAM,GAAG,IAAT;AACAjB,MAAAA,MAAM,CAAC+G,KAAP;AACD;AACF,GAZD,EAf0C,CA2BtC;AACJ;;AAEA,OAAK,IAAII,CAAT,IAAcnH,MAAd,EAAsB;AACpB,QAAI,KAAKmH,CAAL,MAAY7E,SAAZ,IAAyB,OAAOtC,MAAM,CAACmH,CAAD,CAAb,KAAqB,UAAlD,EAA8D;AAC5D,WAAKA,CAAL,IAAU,SAASgB,UAAT,CAAoBC,MAApB,EAA4B;AACpC,eAAO,SAASC,wBAAT,GAAoC;AACzC,iBAAOrI,MAAM,CAACoI,MAAD,CAAN,CAAeP,KAAf,CAAqB7H,MAArB,EAA6B8H,SAA7B,CAAP;AACD,SAFD;AAGD,OAJS,CAIRX,CAJQ,CAAV;AAKD;AACF,GAtCyC,CAsCxC;;;AAGF,OAAK,IAAI7C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhF,YAAY,CAAC5B,MAAjC,EAAyC4G,CAAC,EAA1C,EAA8C;AAC5CtE,IAAAA,MAAM,CAACL,EAAP,CAAUL,YAAY,CAACgF,CAAD,CAAtB,EAA2B,KAAKb,IAAL,CAAU6E,IAAV,CAAe,IAAf,EAAqBhJ,YAAY,CAACgF,CAAD,CAAjC,CAA3B;AACD,GA3CyC,CA2CxC;AACF;;;AAGA,OAAKzC,KAAL,GAAa,UAAUyC,CAAV,EAAa;AACxB/F,IAAAA,KAAK,CAAC,eAAD,EAAkB+F,CAAlB,CAAL;;AAEA,QAAIrD,MAAJ,EAAY;AACVA,MAAAA,MAAM,GAAG,KAAT;AACAjB,MAAAA,MAAM,CAACgH,MAAP;AACD;AACF,GAPD;;AASA,SAAO,IAAP;AACD,CAzDD;;AA2DA,IAAI,OAAOuB,MAAP,KAAkB,UAAtB,EAAkC;AAChCvL,EAAAA,QAAQ,CAACmF,SAAT,CAAmBoG,MAAM,CAACC,aAA1B,IAA2C,YAAY;AACrD,QAAIpJ,iCAAiC,KAAKkD,SAA1C,EAAqD;AACnDlD,MAAAA,iCAAiC,GAAGhC,OAAO,CAAC,mCAAD,CAA3C;AACD;;AAED,WAAOgC,iCAAiC,CAAC,IAAD,CAAxC;AACD,GAND;AAOD;;AAED6C,MAAM,CAACC,cAAP,CAAsBlF,QAAQ,CAACmF,SAA/B,EAA0C,uBAA1C,EAAmE;AACjE;AACA;AACA;AACAC,EAAAA,UAAU,EAAE,KAJqD;AAKjEC,EAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,WAAO,KAAKX,cAAL,CAAoBtB,aAA3B;AACD;AAPgE,CAAnE;AASA6B,MAAM,CAACC,cAAP,CAAsBlF,QAAQ,CAACmF,SAA/B,EAA0C,gBAA1C,EAA4D;AAC1D;AACA;AACA;AACAC,EAAAA,UAAU,EAAE,KAJ8C;AAK1DC,EAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,WAAO,KAAKX,cAAL,IAAuB,KAAKA,cAAL,CAAoBrB,MAAlD;AACD;AAPyD,CAA5D;AASA4B,MAAM,CAACC,cAAP,CAAsBlF,QAAQ,CAACmF,SAA/B,EAA0C,iBAA1C,EAA6D;AAC3D;AACA;AACA;AACAC,EAAAA,UAAU,EAAE,KAJ+C;AAK3DC,EAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,WAAO,KAAKX,cAAL,CAAoBlB,OAA3B;AACD,GAP0D;AAQ3D+B,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaO,KAAb,EAAoB;AACvB,QAAI,KAAKpB,cAAT,EAAyB;AACvB,WAAKA,cAAL,CAAoBlB,OAApB,GAA8BsC,KAA9B;AACD;AACF;AAZ0D,CAA7D,E,CAaI;;AAEJ9F,QAAQ,CAACyL,SAAT,GAAqB5D,QAArB;AACA5C,MAAM,CAACC,cAAP,CAAsBlF,QAAQ,CAACmF,SAA/B,EAA0C,gBAA1C,EAA4D;AAC1D;AACA;AACA;AACAC,EAAAA,UAAU,EAAE,KAJ8C;AAK1DC,EAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,WAAO,KAAKX,cAAL,CAAoBhE,MAA3B;AACD;AAPyD,CAA5D,E,CAQI;AACJ;AACA;AACA;;AAEA,SAASmH,QAAT,CAAkBP,CAAlB,EAAqBxB,KAArB,EAA4B;AAC1B;AACA,MAAIA,KAAK,CAACpF,MAAN,KAAiB,CAArB,EAAwB,OAAO,IAAP;AACxB,MAAIkH,GAAJ;AACA,MAAI9B,KAAK,CAAC5C,UAAV,EAAsB0E,GAAG,GAAG9B,KAAK,CAACzC,MAAN,CAAaqI,KAAb,EAAN,CAAtB,KAAsD,IAAI,CAACpE,CAAD,IAAMA,CAAC,IAAIxB,KAAK,CAACpF,MAArB,EAA6B;AACjF;AACA,QAAIoF,KAAK,CAACtB,OAAV,EAAmBoD,GAAG,GAAG9B,KAAK,CAACzC,MAAN,CAAasI,IAAb,CAAkB,EAAlB,CAAN,CAAnB,KAAoD,IAAI7F,KAAK,CAACzC,MAAN,CAAa3C,MAAb,KAAwB,CAA5B,EAA+BkH,GAAG,GAAG9B,KAAK,CAACzC,MAAN,CAAauI,KAAb,EAAN,CAA/B,KAA+DhE,GAAG,GAAG9B,KAAK,CAACzC,MAAN,CAAawI,MAAb,CAAoB/F,KAAK,CAACpF,MAA1B,CAAN;AACnHoF,IAAAA,KAAK,CAACzC,MAAN,CAAa8D,KAAb;AACD,GAJqD,MAI/C;AACL;AACAS,IAAAA,GAAG,GAAG9B,KAAK,CAACzC,MAAN,CAAayI,OAAb,CAAqBxE,CAArB,EAAwBxB,KAAK,CAACtB,OAA9B,CAAN;AACD;AACD,SAAOoD,GAAP;AACD;;AAED,SAASF,WAAT,CAAqB1E,MAArB,EAA6B;AAC3B,MAAI8C,KAAK,GAAG9C,MAAM,CAAC0B,cAAnB;AACAnD,EAAAA,KAAK,CAAC,aAAD,EAAgBuE,KAAK,CAACpC,UAAtB,CAAL;;AAEA,MAAI,CAACoC,KAAK,CAACpC,UAAX,EAAuB;AACrBoC,IAAAA,KAAK,CAACrC,KAAN,GAAc,IAAd;AACAuE,IAAAA,OAAO,CAACC,QAAR,CAAiB8D,aAAjB,EAAgCjG,KAAhC,EAAuC9C,MAAvC;AACD;AACF;;AAED,SAAS+I,aAAT,CAAuBjG,KAAvB,EAA8B9C,MAA9B,EAAsC;AACpCzB,EAAAA,KAAK,CAAC,eAAD,EAAkBuE,KAAK,CAACpC,UAAxB,EAAoCoC,KAAK,CAACpF,MAA1C,CAAL,CADoC,CACoB;;AAExD,MAAI,CAACoF,KAAK,CAACpC,UAAP,IAAqBoC,KAAK,CAACpF,MAAN,KAAiB,CAA1C,EAA6C;AAC3CoF,IAAAA,KAAK,CAACpC,UAAN,GAAmB,IAAnB;AACAV,IAAAA,MAAM,CAAC2B,QAAP,GAAkB,KAAlB;AACA3B,IAAAA,MAAM,CAACyD,IAAP,CAAY,KAAZ;;AAEA,QAAIX,KAAK,CAAC3B,WAAV,EAAuB;AACrB;AACA;AACA,UAAI6H,MAAM,GAAGhJ,MAAM,CAAC4G,cAApB;;AAEA,UAAI,CAACoC,MAAD,IAAWA,MAAM,CAAC7H,WAAP,IAAsB6H,MAAM,CAACC,QAA5C,EAAsD;AACpDjJ,QAAAA,MAAM,CAAC8B,OAAP;AACD;AACF;AACF;AACF;;AAED,IAAI,OAAOyG,MAAP,KAAkB,UAAtB,EAAkC;AAChCvL,EAAAA,QAAQ,CAACkB,IAAT,GAAgB,UAAUgL,QAAV,EAAoBC,IAApB,EAA0B;AACxC,QAAIjL,IAAI,KAAKoE,SAAb,EAAwB;AACtBpE,MAAAA,IAAI,GAAGd,OAAO,CAAC,yBAAD,CAAd;AACD;;AAED,WAAOc,IAAI,CAAClB,QAAD,EAAWkM,QAAX,EAAqBC,IAArB,CAAX;AACD,GAND;AAOD;;AAED,SAASrC,OAAT,CAAiBsC,EAAjB,EAAqBC,CAArB,EAAwB;AACtB,OAAK,IAAIlC,CAAC,GAAG,CAAR,EAAWmC,CAAC,GAAGF,EAAE,CAAC1L,MAAvB,EAA+ByJ,CAAC,GAAGmC,CAAnC,EAAsCnC,CAAC,EAAvC,EAA2C;AACzC,QAAIiC,EAAE,CAACjC,CAAD,CAAF,KAAUkC,CAAd,EAAiB,OAAOlC,CAAP;AAClB;;AAED,SAAO,CAAC,CAAR;AACD","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}"]},"metadata":{},"sourceType":"script"}