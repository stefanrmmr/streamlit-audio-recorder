{"ast":null,"code":"import _classCallCheck from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { truncateBitmap } from './util/bit';\nimport { popcnt_bit_range } from './util/bit';\nimport { BufferType, UnionMode, Type } from './enum';\nimport { strideForType } from './type';\nimport { toArrayBufferView, toUint8Array, toInt32Array } from './util/buffer';\n/** @ignore */\n\nexport var kUnknownNullCount = -1;\n/** @ignore */\n\nexport var Data = /*#__PURE__*/function () {\n  function Data(type, offset, length, nullCount, buffers, childData, dictionary) {\n    _classCallCheck(this, Data);\n\n    this.type = type;\n    this.dictionary = dictionary;\n    this.offset = Math.floor(Math.max(offset || 0, 0));\n    this.length = Math.floor(Math.max(length || 0, 0));\n    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n    this.childData = (childData || []).map(function (x) {\n      return x instanceof Data ? x : x.data;\n    });\n    var buffer;\n\n    if (buffers instanceof Data) {\n      this.stride = buffers.stride;\n      this.values = buffers.values;\n      this.typeIds = buffers.typeIds;\n      this.nullBitmap = buffers.nullBitmap;\n      this.valueOffsets = buffers.valueOffsets;\n    } else {\n      this.stride = strideForType(type);\n\n      if (buffers) {\n        (buffer = buffers[0]) && (this.valueOffsets = buffer);\n        (buffer = buffers[1]) && (this.values = buffer);\n        (buffer = buffers[2]) && (this.nullBitmap = buffer);\n        (buffer = buffers[3]) && (this.typeIds = buffer);\n      }\n    }\n  }\n\n  _createClass(Data, [{\n    key: \"typeId\",\n    get: function get() {\n      return this.type.typeId;\n    }\n  }, {\n    key: \"ArrayType\",\n    get: function get() {\n      return this.type.ArrayType;\n    }\n  }, {\n    key: \"buffers\",\n    get: function get() {\n      return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];\n    }\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      var byteLength = 0;\n      var valueOffsets = this.valueOffsets,\n          values = this.values,\n          nullBitmap = this.nullBitmap,\n          typeIds = this.typeIds;\n      valueOffsets && (byteLength += valueOffsets.byteLength);\n      values && (byteLength += values.byteLength);\n      nullBitmap && (byteLength += nullBitmap.byteLength);\n      typeIds && (byteLength += typeIds.byteLength);\n      return this.childData.reduce(function (byteLength, child) {\n        return byteLength + child.byteLength;\n      }, byteLength);\n    }\n  }, {\n    key: \"nullCount\",\n    get: function get() {\n      var nullCount = this._nullCount;\n      var nullBitmap;\n\n      if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n        this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n      }\n\n      return nullCount;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(type) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.length;\n      var nullCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._nullCount;\n      var buffers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this;\n      var childData = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.childData;\n      return new Data(type, offset, length, nullCount, buffers, childData, this.dictionary);\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(offset, length) {\n      var stride = this.stride,\n          typeId = this.typeId,\n          childData = this.childData; // +true === 1, +false === 0, so this means\n      // we keep nullCount at 0 if it's already 0,\n      // otherwise set to the invalidated flag -1\n\n      var nullCount = +(this._nullCount === 0) - 1;\n      var childStride = typeId === 16\n      /* FixedSizeList */\n      ? stride : 1;\n\n      var buffers = this._sliceBuffers(offset, length, stride, typeId);\n\n      return this.clone(this.type, this.offset + offset, length, nullCount, buffers, // Don't slice children if we have value offsets (the variable-width types)\n      !childData.length || this.valueOffsets ? childData : this._sliceChildren(childData, childStride * offset, childStride * length));\n    }\n  }, {\n    key: \"_changeLengthAndBackfillNullBitmap\",\n    value: function _changeLengthAndBackfillNullBitmap(newLength) {\n      if (this.typeId === Type.Null) {\n        return this.clone(this.type, 0, newLength, 0);\n      }\n\n      var length = this.length,\n          nullCount = this.nullCount; // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n\n      var bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3); // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n\n      bitmap[length >> 3] = (1 << length - (length & ~7)) - 1; // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n\n      if (nullCount > 0) {\n        bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n      }\n\n      var buffers = this.buffers;\n      buffers[BufferType.VALIDITY] = bitmap;\n      return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n    }\n  }, {\n    key: \"_sliceBuffers\",\n    value: function _sliceBuffers(offset, length, stride, typeId) {\n      var arr,\n          buffers = this.buffers; // If typeIds exist, slice the typeIds buffer\n\n      (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length)); // If offsets exist, only slice the offsets buffer\n\n      (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n      (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n      return buffers;\n    }\n  }, {\n    key: \"_sliceChildren\",\n    value: function _sliceChildren(childData, offset, length) {\n      return childData.map(function (child) {\n        return child.slice(offset, length);\n      });\n    } //\n    // Convenience methods for creating Data instances for each of the Arrow Vector types\n    //\n\n    /** @nocollapse */\n\n  }], [{\n    key: \"new\",\n    value: function _new(type, offset, length, nullCount, buffers, childData, dictionary) {\n      if (buffers instanceof Data) {\n        buffers = buffers.buffers;\n      } else if (!buffers) {\n        buffers = [];\n      }\n\n      switch (type.typeId) {\n        case Type.Null:\n          return Data.Null(type, offset, length);\n\n        case Type.Int:\n          return Data.Int(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Dictionary:\n          return Data.Dictionary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || [], dictionary);\n\n        case Type.Float:\n          return Data.Float(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Bool:\n          return Data.Bool(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Decimal:\n          return Data.Decimal(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Date:\n          return Data.Date(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Time:\n          return Data.Time(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Timestamp:\n          return Data.Timestamp(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Interval:\n          return Data.Interval(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.FixedSizeBinary:\n          return Data.FixedSizeBinary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n        case Type.Binary:\n          return Data.Binary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []);\n\n        case Type.Utf8:\n          return Data.Utf8(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []);\n\n        case Type.List:\n          return Data.List(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]);\n\n        case Type.FixedSizeList:\n          return Data.FixedSizeList(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], (childData || [])[0]);\n\n        case Type.Struct:\n          return Data.Struct(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], childData || []);\n\n        case Type.Map:\n          return Data.Map(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]);\n\n        case Type.Union:\n          return Data.Union(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.TYPE] || [], buffers[BufferType.OFFSET] || childData, childData);\n      }\n\n      throw new Error(\"Unrecognized typeId \".concat(type.typeId));\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Null\",\n    value: function Null(type, offset, length) {\n      return new Data(type, offset, length, 0);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Int\",\n    value: function Int(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Dictionary\",\n    value: function Dictionary(type, offset, length, nullCount, nullBitmap, data, dictionary) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.indices.ArrayType, data), toUint8Array(nullBitmap)], [], dictionary);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Float\",\n    value: function Float(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Bool\",\n    value: function Bool(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Decimal\",\n    value: function Decimal(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Date\",\n    value: function Date(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Time\",\n    value: function Time(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Timestamp\",\n    value: function Timestamp(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Interval\",\n    value: function Interval(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"FixedSizeBinary\",\n    value: function FixedSizeBinary(type, offset, length, nullCount, nullBitmap, data) {\n      return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Binary\",\n    value: function Binary(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Utf8\",\n    value: function Utf8(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"List\",\n    value: function List(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"FixedSizeList\",\n    value: function FixedSizeList(type, offset, length, nullCount, nullBitmap, child) {\n      return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Struct\",\n    value: function Struct(type, offset, length, nullCount, nullBitmap, children) {\n      return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Map\",\n    value: function Map(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {\n      return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"Union\",\n    value: function Union(type, offset, length, nullCount, nullBitmap, typeIds, valueOffsetsOrChildren, children) {\n      var buffers = [undefined, undefined, toUint8Array(nullBitmap), toArrayBufferView(type.ArrayType, typeIds)];\n\n      if (type.mode === UnionMode.Sparse) {\n        return new Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren);\n      }\n\n      buffers[BufferType.OFFSET] = toInt32Array(valueOffsetsOrChildren);\n      return new Data(type, offset, length, nullCount, buffers, children);\n    }\n  }]);\n\n  return Data;\n}();\nData.prototype.childData = Object.freeze([]);","map":{"version":3,"mappings":"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","names":["truncateBitmap","popcnt_bit_range","BufferType","UnionMode","Type","strideForType","toArrayBufferView","toUint8Array","toInt32Array","kUnknownNullCount","Data","type","offset","length","nullCount","buffers","childData","dictionary","Math","floor","max","_nullCount","map","x","data","buffer","stride","values","typeIds","nullBitmap","valueOffsets","typeId","ArrayType","byteLength","reduce","child","childStride","_sliceBuffers","clone","_sliceChildren","newLength","Null","bitmap","Uint8Array","fill","set","VALIDITY","arr","TYPE","subarray","OFFSET","DATA","slice","Int","Dictionary","Float","Bool","Decimal","Date","Time","Timestamp","Interval","FixedSizeBinary","Binary","Utf8","List","FixedSizeList","Struct","Map","Union","Error","undefined","indices","children","valueOffsetsOrChildren","mode","Sparse","prototype","Object","freeze"],"sources":["data.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from './vector';\nimport { truncateBitmap } from './util/bit';\nimport { popcnt_bit_range } from './util/bit';\nimport { BufferType, UnionMode, Type } from './enum';\nimport { DataType, SparseUnion, DenseUnion, strideForType } from './type';\nimport { toArrayBufferView, toUint8Array, toInt32Array } from './util/buffer';\nimport {\n    Dictionary,\n    Null, Int, Float,\n    Binary, Bool, Utf8, Decimal,\n    Date_, Time, Timestamp, Interval,\n    List, Struct, Union, FixedSizeBinary, FixedSizeList, Map_,\n} from './type';\n\n// When slicing, we do not know the null count of the sliced range without\n// doing some computation. To avoid doing this eagerly, we set the null count\n// to -1 (any negative number will do). When Vector.nullCount is called the\n// first time, the null count will be computed. See ARROW-33\n/** @ignore */ export type kUnknownNullCount = -1;\n/** @ignore */ export const kUnknownNullCount = -1;\n\n/** @ignore */ export type NullBuffer = Uint8Array | null | undefined;\n/** @ignore */ export type TypeIdsBuffer = Int8Array  | ArrayLike<number> | Iterable<number> | undefined;\n/** @ignore */ export type ValueOffsetsBuffer = Int32Array  | ArrayLike<number> | Iterable<number> | undefined;\n/** @ignore */ export type DataBuffer<T extends DataType> = T['TArray'] | ArrayLike<number> | Iterable<number> | undefined;\n\n/** @ignore */\nexport interface Buffers<T extends DataType> {\n      [BufferType.OFFSET]: Int32Array;\n        [BufferType.DATA]: T['TArray'];\n    [BufferType.VALIDITY]: Uint8Array;\n        [BufferType.TYPE]: T['TArray'];\n}\n\n/** @ignore */\nexport interface Data<T extends DataType = DataType> {\n    readonly TType: T['TType'];\n    readonly TArray: T['TArray'];\n    readonly TValue: T['TValue'];\n}\n\n/** @ignore */\nexport class Data<T extends DataType = DataType> {\n\n    public readonly type: T;\n    public readonly length: number;\n    public readonly offset: number;\n    public readonly stride: number;\n    public readonly childData: Data[];\n\n    /**\n     * The dictionary for this Vector, if any. Only used for Dictionary type.\n     */\n    public dictionary?: Vector;\n\n    public readonly values: Buffers<T>[BufferType.DATA];\n    // @ts-ignore\n    public readonly typeIds: Buffers<T>[BufferType.TYPE];\n    // @ts-ignore\n    public readonly nullBitmap: Buffers<T>[BufferType.VALIDITY];\n    // @ts-ignore\n    public readonly valueOffsets: Buffers<T>[BufferType.OFFSET];\n\n    public get typeId(): T['TType'] { return this.type.typeId; }\n    public get ArrayType(): T['ArrayType'] { return this.type.ArrayType; }\n    public get buffers() {\n        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds] as Buffers<T>;\n    }\n    public get byteLength(): number {\n        let byteLength = 0;\n        let { valueOffsets, values, nullBitmap, typeIds } = this;\n        valueOffsets && (byteLength += valueOffsets.byteLength);\n        values       && (byteLength += values.byteLength);\n        nullBitmap   && (byteLength += nullBitmap.byteLength);\n        typeIds      && (byteLength += typeIds.byteLength);\n        return this.childData.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);\n    }\n\n    protected _nullCount: number | kUnknownNullCount;\n\n    public get nullCount() {\n        let nullCount = this._nullCount;\n        let nullBitmap: Uint8Array | undefined;\n        if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n            this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n        }\n        return nullCount;\n    }\n\n    constructor(type: T, offset: number, length: number, nullCount?: number, buffers?: Partial<Buffers<T>> | Data<T>, childData?: (Data | Vector)[], dictionary?: Vector) {\n        this.type = type;\n        this.dictionary = dictionary;\n        this.offset = Math.floor(Math.max(offset || 0, 0));\n        this.length = Math.floor(Math.max(length || 0, 0));\n        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n        this.childData = (childData || []).map((x) => x instanceof Data ? x : x.data) as Data[];\n        let buffer: Buffers<T>[keyof Buffers<T>];\n        if (buffers instanceof Data) {\n            this.stride = buffers.stride;\n            this.values = buffers.values;\n            this.typeIds = buffers.typeIds;\n            this.nullBitmap = buffers.nullBitmap;\n            this.valueOffsets = buffers.valueOffsets;\n        } else {\n            this.stride = strideForType(type);\n            if (buffers) {\n                (buffer = (buffers as Buffers<T>)[0]) && (this.valueOffsets = buffer);\n                (buffer = (buffers as Buffers<T>)[1]) && (this.values = buffer);\n                (buffer = (buffers as Buffers<T>)[2]) && (this.nullBitmap = buffer);\n                (buffer = (buffers as Buffers<T>)[3]) && (this.typeIds = buffer);\n            }\n        }\n    }\n\n    public clone<R extends DataType>(type: R, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers: Buffers<R> = <any> this, childData: (Data | Vector)[] = this.childData) {\n        return new Data(type, offset, length, nullCount, buffers, childData, this.dictionary);\n    }\n\n    public slice(offset: number, length: number): Data<T> {\n        const { stride, typeId, childData } = this;\n        // +true === 1, +false === 0, so this means\n        // we keep nullCount at 0 if it's already 0,\n        // otherwise set to the invalidated flag -1\n        const nullCount = +(this._nullCount === 0) - 1;\n        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;\n        const buffers = this._sliceBuffers(offset, length, stride, typeId);\n        return this.clone<T>(this.type, this.offset + offset, length, nullCount, buffers,\n            // Don't slice children if we have value offsets (the variable-width types)\n            (!childData.length || this.valueOffsets) ? childData : this._sliceChildren(childData, childStride * offset, childStride * length));\n    }\n\n    public _changeLengthAndBackfillNullBitmap(newLength: number): Data<T> {\n        if (this.typeId === Type.Null) {\n            return this.clone(this.type, 0, newLength, 0);\n        }\n        const { length, nullCount } = this;\n        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);\n        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;\n        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n        if (nullCount > 0) {\n            bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n        }\n        const buffers = this.buffers;\n        buffers[BufferType.VALIDITY] = bitmap;\n        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n    }\n\n    protected _sliceBuffers(offset: number, length: number, stride: number, typeId: T['TType']): Buffers<T> {\n        let arr: any, { buffers } = this;\n        // If typeIds exist, slice the typeIds buffer\n        (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));\n        // If offsets exist, only slice the offsets buffer\n        (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||\n        // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n        (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n        return buffers;\n    }\n\n    protected _sliceChildren(childData: Data[], offset: number, length: number): Data[] {\n        return childData.map((child) => child.slice(offset, length));\n    }\n\n    //\n    // Convenience methods for creating Data instances for each of the Arrow Vector types\n    //\n    /** @nocollapse */\n    public static new<T extends DataType>(type: T, offset: number, length: number, nullCount?: number, buffers?: Partial<Buffers<T>> | Data<T>, childData?: (Data | Vector)[], dictionary?: Vector): Data<T> {\n        if (buffers instanceof Data) { buffers = buffers.buffers; } else if (!buffers) { buffers = [] as Partial<Buffers<T>>; }\n        switch (type.typeId) {\n            case Type.Null:            return <unknown> Data.Null(            <unknown> type as Null,            offset, length) as Data<T>;\n            case Type.Int:             return <unknown> Data.Int(             <unknown> type as Int,             offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Dictionary:      return <unknown> Data.Dictionary(      <unknown> type as Dictionary,      offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || [], dictionary!) as Data<T>;\n            case Type.Float:           return <unknown> Data.Float(           <unknown> type as Float,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Bool:            return <unknown> Data.Bool(            <unknown> type as Bool,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Decimal:         return <unknown> Data.Decimal(         <unknown> type as Decimal,         offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Date:            return <unknown> Data.Date(            <unknown> type as Date_,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Time:            return <unknown> Data.Time(            <unknown> type as Time,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Timestamp:       return <unknown> Data.Timestamp(       <unknown> type as Timestamp,       offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Interval:        return <unknown> Data.Interval(        <unknown> type as Interval,        offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.FixedSizeBinary: return <unknown> Data.FixedSizeBinary( <unknown> type as FixedSizeBinary, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Binary:          return <unknown> Data.Binary(          <unknown> type as Binary,          offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Utf8:            return <unknown> Data.Utf8(            <unknown> type as Utf8,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.List:            return <unknown> Data.List(            <unknown> type as List,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]) as Data<T>;\n            case Type.FixedSizeList:   return <unknown> Data.FixedSizeList(   <unknown> type as FixedSizeList,   offset, length, nullCount || 0, buffers[BufferType.VALIDITY], (childData || [])[0]) as Data<T>;\n            case Type.Struct:          return <unknown> Data.Struct(          <unknown> type as Struct,          offset, length, nullCount || 0, buffers[BufferType.VALIDITY], childData || []) as Data<T>;\n            case Type.Map:             return <unknown> Data.Map(             <unknown> type as Map_,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]) as Data<T>;\n            case Type.Union:           return <unknown> Data.Union(           <unknown> type as Union,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.TYPE] || [], buffers[BufferType.OFFSET] || childData, childData) as Data<T>;\n        }\n        throw new Error(`Unrecognized typeId ${type.typeId}`);\n    }\n\n    /** @nocollapse */\n    public static Null<T extends Null>(type: T, offset: number, length: number) {\n        return new Data(type, offset, length, 0);\n    }\n    /** @nocollapse */\n    public static Int<T extends Int>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Dictionary<T extends Dictionary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>, dictionary: Vector<T['dictionary']>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView<T['TArray']>(type.indices.ArrayType, data), toUint8Array(nullBitmap)], [], dictionary);\n    }\n    /** @nocollapse */\n    public static Float<T extends Float>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Bool<T extends Bool>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Decimal<T extends Decimal>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Date<T extends Date_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Time<T extends Time>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Timestamp<T extends Timestamp>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Interval<T extends Interval>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static FixedSizeBinary<T extends FixedSizeBinary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Binary<T extends Binary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Utf8<T extends Utf8>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static List<T extends List>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, child: Data<T['valueType']> | Vector<T['valueType']>) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static FixedSizeList<T extends FixedSizeList>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, child: Data<T['valueType']> | Vector<T['valueType']>) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static Struct<T extends Struct>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, children: (Data | Vector)[]) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n    }\n    /** @nocollapse */\n    public static Map<T extends Map_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, child: (Data | Vector)) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    public static Union<T extends SparseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, children: (Data | Vector)[], _?: any): Data<T>;\n    public static Union<T extends DenseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsets: ValueOffsetsBuffer, children: (Data | Vector)[]): Data<T>;\n    public static Union<T extends Union>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsetsOrChildren: ValueOffsetsBuffer | (Data | Vector)[], children?: (Data | Vector)[]): Data<T>;\n    /** @nocollapse */\n    public static Union<T extends Union>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsetsOrChildren: ValueOffsetsBuffer | (Data | Vector)[], children?: (Data | Vector)[]) {\n        const buffers = <unknown> [\n            undefined, undefined,\n            toUint8Array(nullBitmap),\n            toArrayBufferView(type.ArrayType, typeIds)\n        ] as Partial<Buffers<T>>;\n        if (type.mode === UnionMode.Sparse) {\n            return new Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren as (Data | Vector)[]);\n        }\n        buffers[BufferType.OFFSET] = toInt32Array(<ValueOffsetsBuffer> valueOffsetsOrChildren);\n        return new Data(type, offset, length, nullCount, buffers, children);\n    }\n}\n\n(Data.prototype as any).childData = Object.freeze([]);\n"]},"metadata":{},"sourceType":"module"}