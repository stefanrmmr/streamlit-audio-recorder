{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\n\nconst wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\n\nfunction pd(event) {\n  const retv = privateData.get(event);\n  console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\n\n\nfunction setCancelFlag(data) {\n  if (data.passiveListener != null) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n    }\n\n    return;\n  }\n\n  if (!data.event.cancelable) {\n    return;\n  }\n\n  data.canceled = true;\n\n  if (typeof data.event.preventDefault === \"function\") {\n    data.event.preventDefault();\n  }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\n\n\nfunction Event(eventTarget, event) {\n  privateData.set(this, {\n    eventTarget,\n    event,\n    eventPhase: 2,\n    currentTarget: eventTarget,\n    canceled: false,\n    stopped: false,\n    immediateStopped: false,\n    passiveListener: null,\n    timeStamp: event.timeStamp || Date.now()\n  }); // https://heycam.github.io/webidl/#Unforgeable\n\n  Object.defineProperty(this, \"isTrusted\", {\n    value: false,\n    enumerable: true\n  }); // Define accessors\n\n  const keys = Object.keys(event);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in this)) {\n      Object.defineProperty(this, key, defineRedirectDescriptor(key));\n    }\n  }\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEvent.prototype = {\n  /**\n   * The type of this event.\n   * @type {string}\n   */\n  get type() {\n    return pd(this).event.type;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get target() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    return pd(this).currentTarget;\n  },\n\n  /**\n   * @returns {EventTarget[]} The composed path of this event.\n   */\n  composedPath() {\n    const currentTarget = pd(this).currentTarget;\n\n    if (currentTarget == null) {\n      return [];\n    }\n\n    return [currentTarget];\n  },\n\n  /**\n   * Constant of NONE.\n   * @type {number}\n   */\n  get NONE() {\n    return 0;\n  },\n\n  /**\n   * Constant of CAPTURING_PHASE.\n   * @type {number}\n   */\n  get CAPTURING_PHASE() {\n    return 1;\n  },\n\n  /**\n   * Constant of AT_TARGET.\n   * @type {number}\n   */\n  get AT_TARGET() {\n    return 2;\n  },\n\n  /**\n   * Constant of BUBBLING_PHASE.\n   * @type {number}\n   */\n  get BUBBLING_PHASE() {\n    return 3;\n  },\n\n  /**\n   * The target of this event.\n   * @type {number}\n   */\n  get eventPhase() {\n    return pd(this).eventPhase;\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopPropagation() {\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.stopPropagation === \"function\") {\n      data.event.stopPropagation();\n    }\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopImmediatePropagation() {\n    const data = pd(this);\n    data.stopped = true;\n    data.immediateStopped = true;\n\n    if (typeof data.event.stopImmediatePropagation === \"function\") {\n      data.event.stopImmediatePropagation();\n    }\n  },\n\n  /**\n   * The flag to be bubbling.\n   * @type {boolean}\n   */\n  get bubbles() {\n    return Boolean(pd(this).event.bubbles);\n  },\n\n  /**\n   * The flag to be cancelable.\n   * @type {boolean}\n   */\n  get cancelable() {\n    return Boolean(pd(this).event.cancelable);\n  },\n\n  /**\n   * Cancel this event.\n   * @returns {void}\n   */\n  preventDefault() {\n    setCancelFlag(pd(this));\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    return pd(this).canceled;\n  },\n\n  /**\n   * The flag to be composed.\n   * @type {boolean}\n   */\n  get composed() {\n    return Boolean(pd(this).event.composed);\n  },\n\n  /**\n   * The unix time of this event.\n   * @type {number}\n   */\n  get timeStamp() {\n    return pd(this).timeStamp;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   * @deprecated\n   */\n  get srcElement() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The flag to stop event bubbling.\n   * @type {boolean}\n   * @deprecated\n   */\n  get cancelBubble() {\n    return pd(this).stopped;\n  },\n\n  set cancelBubble(value) {\n    if (!value) {\n      return;\n    }\n\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.cancelBubble === \"boolean\") {\n      data.event.cancelBubble = true;\n    }\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   * @deprecated\n   */\n  get returnValue() {\n    return !pd(this).canceled;\n  },\n\n  set returnValue(value) {\n    if (!value) {\n      setCancelFlag(pd(this));\n    }\n  },\n\n  /**\n   * Initialize this event object. But do nothing under event dispatching.\n   * @param {string} type The event type.\n   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n   * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n   * @deprecated\n   */\n  initEvent() {// Do nothing.\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(Event.prototype, \"constructor\", {\n  value: Event,\n  configurable: true,\n  writable: true\n}); // Ensure `event instanceof window.Event` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, window.Event.prototype); // Make association for wrappers.\n\n  wrappers.set(window.Event.prototype, Event);\n}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\n\n\nfunction defineRedirectDescriptor(key) {\n  return {\n    get() {\n      return pd(this).event[key];\n    },\n\n    set(value) {\n      pd(this).event[key] = value;\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\n\n\nfunction defineCallDescriptor(key) {\n  return {\n    value() {\n      const event = pd(this).event;\n      return event[key].apply(event, arguments);\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\n\n\nfunction defineWrapper(BaseEvent, proto) {\n  const keys = Object.keys(proto);\n\n  if (keys.length === 0) {\n    return BaseEvent;\n  }\n  /** CustomEvent */\n\n\n  function CustomEvent(eventTarget, event) {\n    BaseEvent.call(this, eventTarget, event);\n  }\n\n  CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n    constructor: {\n      value: CustomEvent,\n      configurable: true,\n      writable: true\n    }\n  }); // Define accessors.\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in BaseEvent.prototype)) {\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n      const isFunc = typeof descriptor.value === \"function\";\n      Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n    }\n  }\n\n  return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\n\n\nfunction getWrapper(proto) {\n  if (proto == null || proto === Object.prototype) {\n    return Event;\n  }\n\n  let wrapper = wrappers.get(proto);\n\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n    wrappers.set(proto, wrapper);\n  }\n\n  return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\n\n\nfunction wrapEvent(eventTarget, event) {\n  const Wrapper = getWrapper(Object.getPrototypeOf(event));\n  return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\n\n\nfunction isStopped(event) {\n  return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\n\n\nfunction setEventPhase(event, eventPhase) {\n  pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\n\n\nfunction setCurrentTarget(event, currentTarget) {\n  pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\n\n\nfunction setPassiveListener(event, passiveListener) {\n  pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\n\n\nconst listenersMap = new WeakMap(); // Listener types\n\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\n\nfunction isObject(x) {\n  return x !== null && typeof x === \"object\"; //eslint-disable-line no-restricted-syntax\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\n\n\nfunction getListeners(eventTarget) {\n  const listeners = listenersMap.get(eventTarget);\n\n  if (listeners == null) {\n    throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n  }\n\n  return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\n\n\nfunction defineEventAttributeDescriptor(eventName) {\n  return {\n    get() {\n      const listeners = getListeners(this);\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          return node.listener;\n        }\n\n        node = node.next;\n      }\n\n      return null;\n    },\n\n    set(listener) {\n      if (typeof listener !== \"function\" && !isObject(listener)) {\n        listener = null; // eslint-disable-line no-param-reassign\n      }\n\n      const listeners = getListeners(this); // Traverse to the tail while removing old value.\n\n      let prev = null;\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          // Remove old value.\n          if (prev !== null) {\n            prev.next = node.next;\n          } else if (node.next !== null) {\n            listeners.set(eventName, node.next);\n          } else {\n            listeners.delete(eventName);\n          }\n        } else {\n          prev = node;\n        }\n\n        node = node.next;\n      } // Add new value.\n\n\n      if (listener !== null) {\n        const newNode = {\n          listener,\n          listenerType: ATTRIBUTE,\n          passive: false,\n          once: false,\n          next: null\n        };\n\n        if (prev === null) {\n          listeners.set(eventName, newNode);\n        } else {\n          prev.next = newNode;\n        }\n      }\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\n\n\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n  Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\n\n\nfunction defineCustomEventTarget(eventNames) {\n  /** CustomEventTarget */\n  function CustomEventTarget() {\n    EventTarget.call(this);\n  }\n\n  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n    constructor: {\n      value: CustomEventTarget,\n      configurable: true,\n      writable: true\n    }\n  });\n\n  for (let i = 0; i < eventNames.length; ++i) {\n    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n  }\n\n  return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\n\n\nfunction EventTarget() {\n  /*eslint-disable consistent-return */\n  if (this instanceof EventTarget) {\n    listenersMap.set(this, new Map());\n    return;\n  }\n\n  if (arguments.length === 1 && Array.isArray(arguments[0])) {\n    return defineCustomEventTarget(arguments[0]);\n  }\n\n  if (arguments.length > 0) {\n    const types = new Array(arguments.length);\n\n    for (let i = 0; i < arguments.length; ++i) {\n      types[i] = arguments[i];\n    }\n\n    return defineCustomEventTarget(types);\n  }\n\n  throw new TypeError(\"Cannot call a class as a function\");\n  /*eslint-enable consistent-return */\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEventTarget.prototype = {\n  /**\n   * Add a given listener to this event target.\n   * @param {string} eventName The event name to add.\n   * @param {Function} listener The listener to add.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  addEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    if (typeof listener !== \"function\" && !isObject(listener)) {\n      throw new TypeError(\"'listener' should be a function or an object.\");\n    }\n\n    const listeners = getListeners(this);\n    const optionsIsObj = isObject(options);\n    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    const newNode = {\n      listener,\n      listenerType,\n      passive: optionsIsObj && Boolean(options.passive),\n      once: optionsIsObj && Boolean(options.once),\n      next: null\n    }; // Set it as the first node if the first node is null.\n\n    let node = listeners.get(eventName);\n\n    if (node === undefined) {\n      listeners.set(eventName, newNode);\n      return;\n    } // Traverse to the tail while checking duplication..\n\n\n    let prev = null;\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        // Should ignore duplication.\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    } // Add it.\n\n\n    prev.next = newNode;\n  },\n\n  /**\n   * Remove a given listener from this event target.\n   * @param {string} eventName The event name to remove.\n   * @param {Function} listener The listener to remove.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  removeEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    const listeners = getListeners(this);\n    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    let prev = null;\n    let node = listeners.get(eventName);\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    }\n  },\n\n  /**\n   * Dispatch a given event.\n   * @param {Event|{type:string}} event The event to dispatch.\n   * @returns {boolean} `false` if canceled.\n   */\n  dispatchEvent(event) {\n    if (event == null || typeof event.type !== \"string\") {\n      throw new TypeError('\"event.type\" should be a string.');\n    } // If listeners aren't registered, terminate.\n\n\n    const listeners = getListeners(this);\n    const eventName = event.type;\n    let node = listeners.get(eventName);\n\n    if (node == null) {\n      return true;\n    } // Since we cannot rewrite several properties, so wrap object.\n\n\n    const wrappedEvent = wrapEvent(this, event); // This doesn't process capturing phase and bubbling phase.\n    // This isn't participating in a tree.\n\n    let prev = null;\n\n    while (node != null) {\n      // Remove this listener if it's once\n      if (node.once) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n      } else {\n        prev = node;\n      } // Call this listener\n\n\n      setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n\n      if (typeof node.listener === \"function\") {\n        try {\n          node.listener.call(this, wrappedEvent);\n        } catch (err) {\n          if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(err);\n          }\n        }\n      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n        node.listener.handleEvent(wrappedEvent);\n      } // Break if `event.stopImmediatePropagation` was called.\n\n\n      if (isStopped(wrappedEvent)) {\n        break;\n      }\n\n      node = node.next;\n    }\n\n    setPassiveListener(wrappedEvent, null);\n    setEventPhase(wrappedEvent, 0);\n    setCurrentTarget(wrappedEvent, null);\n    return !wrappedEvent.defaultPrevented;\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n  value: EventTarget,\n  configurable: true,\n  writable: true\n}); // Ensure `eventTarget instanceof window.EventTarget` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };","map":{"version":3,"mappings":"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","names":["privateData","WeakMap","wrappers","pd","event","retv","get","console","assert","setCancelFlag","data","passiveListener","error","cancelable","canceled","preventDefault","Event","eventTarget","set","eventPhase","currentTarget","stopped","immediateStopped","timeStamp","Date","now","Object","defineProperty","value","enumerable","keys","i","length","key","defineRedirectDescriptor","prototype","type","target","composedPath","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","stopPropagation","stopImmediatePropagation","bubbles","Boolean","defaultPrevented","composed","srcElement","cancelBubble","returnValue","initEvent","configurable","writable","window","setPrototypeOf","defineCallDescriptor","apply","arguments","defineWrapper","BaseEvent","proto","CustomEvent","call","create","constructor","descriptor","getOwnPropertyDescriptor","isFunc","getWrapper","wrapper","getPrototypeOf","wrapEvent","Wrapper","isStopped","setEventPhase","setCurrentTarget","setPassiveListener","listenersMap","CAPTURE","BUBBLE","ATTRIBUTE","isObject","x","getListeners","listeners","TypeError","defineEventAttributeDescriptor","eventName","node","listenerType","listener","next","prev","delete","newNode","passive","once","defineEventAttribute","eventTargetPrototype","defineCustomEventTarget","eventNames","CustomEventTarget","EventTarget","Map","Array","isArray","types","addEventListener","options","optionsIsObj","capture","undefined","removeEventListener","dispatchEvent","wrappedEvent","err","handleEvent"],"sources":["../src/event.mjs","../src/event-target.mjs"],"sourcesContent":["/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            )\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault()\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        data.immediateStopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this))\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this))\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = typeof descriptor.value === \"function\"\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import {\n    isStopped,\n    setCurrentTarget,\n    setEventPhase,\n    setPassiveListener,\n    wrapEvent,\n} from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    } else {\n                        listeners.delete(eventName)\n                    }\n                } else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                } else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    )\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n                return\n            }\n\n            prev = node\n            node = node.next\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n            } else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            )\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err)\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n"]},"metadata":{},"sourceType":"module"}