{"ast":null,"code":"import _toConsumableArray from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _construct from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _inherits from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/stefan_rmmr/software_dev/streamlit_audio_recorder/st_audiorec/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DictionaryVector } from '../vector/dictionary';\n/** @ignore */\n\nexport var Value = /*#__PURE__*/function () {\n  function Value() {\n    _classCallCheck(this, Value);\n  }\n\n  _createClass(Value, [{\n    key: \"eq\",\n    value: function eq(other) {\n      if (!(other instanceof Value)) {\n        other = new Literal(other);\n      }\n\n      return new Equals(this, other);\n    }\n  }, {\n    key: \"le\",\n    value: function le(other) {\n      if (!(other instanceof Value)) {\n        other = new Literal(other);\n      }\n\n      return new LTeq(this, other);\n    }\n  }, {\n    key: \"ge\",\n    value: function ge(other) {\n      if (!(other instanceof Value)) {\n        other = new Literal(other);\n      }\n\n      return new GTeq(this, other);\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(other) {\n      return new Not(this.ge(other));\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(other) {\n      return new Not(this.le(other));\n    }\n  }, {\n    key: \"ne\",\n    value: function ne(other) {\n      return new Not(this.eq(other));\n    }\n  }]);\n\n  return Value;\n}();\n/** @ignore */\n\nexport var Literal = /*#__PURE__*/function (_Value) {\n  _inherits(Literal, _Value);\n\n  var _super = _createSuper(Literal);\n\n  function Literal(v) {\n    var _this;\n\n    _classCallCheck(this, Literal);\n\n    _this = _super.call(this);\n    _this.v = v;\n    return _this;\n  }\n\n  return _createClass(Literal);\n}(Value);\n/** @ignore */\n\nexport var Col = /*#__PURE__*/function (_Value2) {\n  _inherits(Col, _Value2);\n\n  var _super2 = _createSuper(Col);\n\n  function Col(name) {\n    var _this2;\n\n    _classCallCheck(this, Col);\n\n    _this2 = _super2.call(this);\n    _this2.name = name;\n    return _this2;\n  }\n\n  _createClass(Col, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      if (!this.colidx) {\n        // Assume column index doesn't change between calls to bind\n        //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n        this.colidx = -1;\n        var fields = batch.schema.fields;\n\n        for (var idx = -1; ++idx < fields.length;) {\n          if (fields[idx].name === this.name) {\n            this.colidx = idx;\n            break;\n          }\n        }\n\n        if (this.colidx < 0) {\n          throw new Error(\"Failed to bind Col \\\"\".concat(this.name, \"\\\"\"));\n        }\n      }\n\n      var vec = this.vector = batch.getChildAt(this.colidx);\n      return function (idx) {\n        return vec.get(idx);\n      };\n    }\n  }]);\n\n  return Col;\n}(Value);\n/** @ignore */\n\nexport var Predicate = /*#__PURE__*/function () {\n  function Predicate() {\n    _classCallCheck(this, Predicate);\n  }\n\n  _createClass(Predicate, [{\n    key: \"and\",\n    value: function and() {\n      for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n        expr[_key] = arguments[_key];\n      }\n\n      return _construct(And, [this].concat(expr));\n    }\n  }, {\n    key: \"or\",\n    value: function or() {\n      for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        expr[_key2] = arguments[_key2];\n      }\n\n      return _construct(Or, [this].concat(expr));\n    }\n  }, {\n    key: \"not\",\n    value: function not() {\n      return new Not(this);\n    }\n  }]);\n\n  return Predicate;\n}();\n/** @ignore */\n\nexport var ComparisonPredicate = /*#__PURE__*/function (_Predicate) {\n  _inherits(ComparisonPredicate, _Predicate);\n\n  var _super3 = _createSuper(ComparisonPredicate);\n\n  function ComparisonPredicate(left, right) {\n    var _this3;\n\n    _classCallCheck(this, ComparisonPredicate);\n\n    _this3 = _super3.call(this);\n    _this3.left = left;\n    _this3.right = right;\n    return _this3;\n  }\n\n  _createClass(ComparisonPredicate, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      if (this.left instanceof Literal) {\n        if (this.right instanceof Literal) {\n          return this._bindLitLit(batch, this.left, this.right);\n        } else {\n          // right is a Col\n          return this._bindLitCol(batch, this.left, this.right);\n        }\n      } else {\n        // left is a Col\n        if (this.right instanceof Literal) {\n          return this._bindColLit(batch, this.left, this.right);\n        } else {\n          // right is a Col\n          return this._bindColCol(batch, this.left, this.right);\n        }\n      }\n    }\n  }]);\n\n  return ComparisonPredicate;\n}(Predicate);\n/** @ignore */\n\nexport var CombinationPredicate = /*#__PURE__*/function (_Predicate2) {\n  _inherits(CombinationPredicate, _Predicate2);\n\n  var _super4 = _createSuper(CombinationPredicate);\n\n  function CombinationPredicate() {\n    var _this4;\n\n    _classCallCheck(this, CombinationPredicate);\n\n    _this4 = _super4.call(this);\n\n    for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      children[_key3] = arguments[_key3];\n    }\n\n    _this4.children = children;\n    return _this4;\n  }\n\n  return _createClass(CombinationPredicate);\n}(Predicate); // add children to prototype so it doesn't get mangled in es2015/umd\n\nCombinationPredicate.prototype.children = Object.freeze([]); // freeze for safety\n\n/** @ignore */\n\nexport var And = /*#__PURE__*/function (_CombinationPredicate) {\n  _inherits(And, _CombinationPredicate);\n\n  var _super5 = _createSuper(And);\n\n  function And() {\n    for (var _len4 = arguments.length, children = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      children[_key4] = arguments[_key4];\n    }\n\n    _classCallCheck(this, And);\n\n    // Flatten any Ands\n    children = children.reduce(function (accum, p) {\n      return accum.concat(p instanceof And ? p.children : p);\n    }, []);\n    return _super5.call.apply(_super5, [this].concat(_toConsumableArray(children)));\n  }\n\n  _createClass(And, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      var bound = this.children.map(function (p) {\n        return p.bind(batch);\n      });\n      return function (idx, batch) {\n        return bound.every(function (p) {\n          return p(idx, batch);\n        });\n      };\n    }\n  }]);\n\n  return And;\n}(CombinationPredicate);\n/** @ignore */\n\nexport var Or = /*#__PURE__*/function (_CombinationPredicate2) {\n  _inherits(Or, _CombinationPredicate2);\n\n  var _super6 = _createSuper(Or);\n\n  function Or() {\n    for (var _len5 = arguments.length, children = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      children[_key5] = arguments[_key5];\n    }\n\n    _classCallCheck(this, Or);\n\n    // Flatten any Ors\n    children = children.reduce(function (accum, p) {\n      return accum.concat(p instanceof Or ? p.children : p);\n    }, []);\n    return _super6.call.apply(_super6, [this].concat(_toConsumableArray(children)));\n  }\n\n  _createClass(Or, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      var bound = this.children.map(function (p) {\n        return p.bind(batch);\n      });\n      return function (idx, batch) {\n        return bound.some(function (p) {\n          return p(idx, batch);\n        });\n      };\n    }\n  }]);\n\n  return Or;\n}(CombinationPredicate);\n/** @ignore */\n\nexport var Equals = /*#__PURE__*/function (_ComparisonPredicate) {\n  _inherits(Equals, _ComparisonPredicate);\n\n  var _super7 = _createSuper(Equals);\n\n  function Equals() {\n    _classCallCheck(this, Equals);\n\n    return _super7.apply(this, arguments);\n  }\n\n  _createClass(Equals, [{\n    key: \"_bindLitLit\",\n    value: function _bindLitLit(_batch, left, right) {\n      var rtrn = left.v == right.v;\n      return function () {\n        return rtrn;\n      };\n    }\n  }, {\n    key: \"_bindColCol\",\n    value: function _bindColCol(batch, left, right) {\n      var left_func = left.bind(batch);\n      var right_func = right.bind(batch);\n      return function (idx, batch) {\n        return left_func(idx, batch) == right_func(idx, batch);\n      };\n    }\n  }, {\n    key: \"_bindColLit\",\n    value: function _bindColLit(batch, col, lit) {\n      var col_func = col.bind(batch);\n\n      if (col.vector instanceof DictionaryVector) {\n        var key;\n        var vector = col.vector;\n\n        if (vector.dictionary !== this.lastDictionary) {\n          key = vector.reverseLookup(lit.v);\n          this.lastDictionary = vector.dictionary;\n          this.lastKey = key;\n        } else {\n          key = this.lastKey;\n        }\n\n        if (key === -1) {\n          // the value doesn't exist in the dictionary - always return\n          // false\n          // TODO: special-case of PredicateFunc that encapsulates this\n          // \"always false\" behavior. That way filtering operations don't\n          // have to bother checking\n          return function () {\n            return false;\n          };\n        } else {\n          return function (idx) {\n            return vector.getKey(idx) === key;\n          };\n        }\n      } else {\n        return function (idx, cols) {\n          return col_func(idx, cols) == lit.v;\n        };\n      }\n    }\n  }, {\n    key: \"_bindLitCol\",\n    value: function _bindLitCol(batch, lit, col) {\n      // Equals is commutative\n      return this._bindColLit(batch, col, lit);\n    }\n  }]);\n\n  return Equals;\n}(ComparisonPredicate);\n/** @ignore */\n\nexport var LTeq = /*#__PURE__*/function (_ComparisonPredicate2) {\n  _inherits(LTeq, _ComparisonPredicate2);\n\n  var _super8 = _createSuper(LTeq);\n\n  function LTeq() {\n    _classCallCheck(this, LTeq);\n\n    return _super8.apply(this, arguments);\n  }\n\n  _createClass(LTeq, [{\n    key: \"_bindLitLit\",\n    value: function _bindLitLit(_batch, left, right) {\n      var rtrn = left.v <= right.v;\n      return function () {\n        return rtrn;\n      };\n    }\n  }, {\n    key: \"_bindColCol\",\n    value: function _bindColCol(batch, left, right) {\n      var left_func = left.bind(batch);\n      var right_func = right.bind(batch);\n      return function (idx, cols) {\n        return left_func(idx, cols) <= right_func(idx, cols);\n      };\n    }\n  }, {\n    key: \"_bindColLit\",\n    value: function _bindColLit(batch, col, lit) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return col_func(idx, cols) <= lit.v;\n      };\n    }\n  }, {\n    key: \"_bindLitCol\",\n    value: function _bindLitCol(batch, lit, col) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return lit.v <= col_func(idx, cols);\n      };\n    }\n  }]);\n\n  return LTeq;\n}(ComparisonPredicate);\n/** @ignore */\n\nexport var GTeq = /*#__PURE__*/function (_ComparisonPredicate3) {\n  _inherits(GTeq, _ComparisonPredicate3);\n\n  var _super9 = _createSuper(GTeq);\n\n  function GTeq() {\n    _classCallCheck(this, GTeq);\n\n    return _super9.apply(this, arguments);\n  }\n\n  _createClass(GTeq, [{\n    key: \"_bindLitLit\",\n    value: function _bindLitLit(_batch, left, right) {\n      var rtrn = left.v >= right.v;\n      return function () {\n        return rtrn;\n      };\n    }\n  }, {\n    key: \"_bindColCol\",\n    value: function _bindColCol(batch, left, right) {\n      var left_func = left.bind(batch);\n      var right_func = right.bind(batch);\n      return function (idx, cols) {\n        return left_func(idx, cols) >= right_func(idx, cols);\n      };\n    }\n  }, {\n    key: \"_bindColLit\",\n    value: function _bindColLit(batch, col, lit) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return col_func(idx, cols) >= lit.v;\n      };\n    }\n  }, {\n    key: \"_bindLitCol\",\n    value: function _bindLitCol(batch, lit, col) {\n      var col_func = col.bind(batch);\n      return function (idx, cols) {\n        return lit.v >= col_func(idx, cols);\n      };\n    }\n  }]);\n\n  return GTeq;\n}(ComparisonPredicate);\n/** @ignore */\n\nexport var Not = /*#__PURE__*/function (_Predicate3) {\n  _inherits(Not, _Predicate3);\n\n  var _super10 = _createSuper(Not);\n\n  function Not(child) {\n    var _this5;\n\n    _classCallCheck(this, Not);\n\n    _this5 = _super10.call(this);\n    _this5.child = child;\n    return _this5;\n  }\n\n  _createClass(Not, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      var func = this.child.bind(batch);\n      return function (idx, batch) {\n        return !func(idx, batch);\n      };\n    }\n  }]);\n\n  return Not;\n}(Predicate);\n/** @ignore */\n\nexport var CustomPredicate = /*#__PURE__*/function (_Predicate4) {\n  _inherits(CustomPredicate, _Predicate4);\n\n  var _super11 = _createSuper(CustomPredicate);\n\n  function CustomPredicate(next, bind_) {\n    var _this6;\n\n    _classCallCheck(this, CustomPredicate);\n\n    _this6 = _super11.call(this);\n    _this6.next = next;\n    _this6.bind_ = bind_;\n    return _this6;\n  }\n\n  _createClass(CustomPredicate, [{\n    key: \"bind\",\n    value: function bind(batch) {\n      this.bind_(batch);\n      return this.next;\n    }\n  }]);\n\n  return CustomPredicate;\n}(Predicate);\nexport function lit(v) {\n  return new Literal(v);\n}\nexport function col(n) {\n  return new Col(n);\n}\nexport function and() {\n  for (var _len6 = arguments.length, p = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    p[_key6] = arguments[_key6];\n  }\n\n  return _construct(And, p);\n}\nexport function or() {\n  for (var _len7 = arguments.length, p = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    p[_key7] = arguments[_key7];\n  }\n\n  return _construct(Or, p);\n}\nexport function custom(next, bind) {\n  return new CustomPredicate(next, bind);\n}","map":{"version":3,"mappings":"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","names":["DictionaryVector","Value","other","Literal","Equals","LTeq","GTeq","Not","ge","le","eq","v","Col","name","batch","colidx","fields","schema","idx","length","Error","vec","vector","getChildAt","get","Predicate","expr","And","Or","ComparisonPredicate","left","right","_bindLitLit","_bindLitCol","_bindColLit","_bindColCol","CombinationPredicate","children","prototype","Object","freeze","reduce","accum","p","concat","bound","map","bind","every","some","_batch","rtrn","left_func","right_func","col","lit","col_func","key","dictionary","lastDictionary","reverseLookup","lastKey","getKey","cols","child","func","CustomPredicate","next","bind_","n","and","or","custom"],"sources":["compute/predicate.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { RecordBatch } from '../recordbatch';\nimport { DictionaryVector } from '../vector/dictionary';\n\n/** @ignore */\nexport type ValueFunc<T> = (idx: number, cols: RecordBatch) => T | null;\n/** @ignore */\nexport type PredicateFunc = (idx: number, cols: RecordBatch) => boolean;\n\n/** @ignore */\nexport abstract class Value<T> {\n    eq(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new Equals(this, other);\n    }\n    le(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new LTeq(this, other);\n    }\n    ge(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new GTeq(this, other);\n    }\n    lt(other: Value<T> | T): Predicate {\n        return new Not(this.ge(other));\n    }\n    gt(other: Value<T> | T): Predicate {\n        return new Not(this.le(other));\n    }\n    ne(other: Value<T> | T): Predicate {\n        return new Not(this.eq(other));\n    }\n}\n\n/** @ignore */\nexport class Literal<T= any> extends Value<T> {\n    constructor(public v: T) { super(); }\n}\n\n/** @ignore */\nexport class Col<T= any> extends Value<T> {\n    // @ts-ignore\n    public vector: Vector;\n    // @ts-ignore\n    public colidx: number;\n\n    constructor(public name: string) { super(); }\n    bind(batch: RecordBatch): (idx: number, batch?: RecordBatch) => any {\n        if (!this.colidx) {\n            // Assume column index doesn't change between calls to bind\n            //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n            this.colidx = -1;\n            const fields = batch.schema.fields;\n            for (let idx = -1; ++idx < fields.length;) {\n                if (fields[idx].name === this.name) {\n                    this.colidx = idx;\n                    break;\n                }\n            }\n            if (this.colidx < 0) { throw new Error(`Failed to bind Col \"${this.name}\"`); }\n        }\n\n        const vec = this.vector = batch.getChildAt(this.colidx)!;\n        return (idx: number) => vec.get(idx);\n    }\n}\n\n/** @ignore */\nexport abstract class Predicate {\n    abstract bind(batch: RecordBatch): PredicateFunc;\n    and(...expr: Predicate[]): And { return new And(this, ...expr); }\n    or(...expr: Predicate[]): Or { return new Or(this, ...expr); }\n    not(): Predicate { return new Not(this); }\n}\n\n/** @ignore */\nexport abstract class ComparisonPredicate<T= any> extends Predicate {\n    constructor(public readonly left: Value<T>, public readonly right: Value<T>) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        if (this.left instanceof Literal) {\n            if (this.right instanceof Literal) {\n                return this._bindLitLit(batch, this.left, this.right);\n            } else { // right is a Col\n\n                return this._bindLitCol(batch, this.left, this.right as Col);\n            }\n        } else { // left is a Col\n            if (this.right instanceof Literal) {\n                return this._bindColLit(batch, this.left as Col, this.right);\n            } else { // right is a Col\n                return this._bindColCol(batch, this.left as Col, this.right as Col);\n            }\n        }\n    }\n\n    protected abstract _bindLitLit(batch: RecordBatch, left: Literal, right: Literal): PredicateFunc;\n    protected abstract _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc;\n    protected abstract _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc;\n    protected abstract _bindLitCol(batch: RecordBatch, lit: Literal, col: Col): PredicateFunc;\n}\n\n/** @ignore */\nexport abstract class CombinationPredicate extends Predicate {\n    readonly children: Predicate[];\n    constructor(...children: Predicate[]) {\n        super();\n        this.children = children;\n    }\n}\n// add children to prototype so it doesn't get mangled in es2015/umd\n(<any> CombinationPredicate.prototype).children = Object.freeze([]); // freeze for safety\n\n/** @ignore */\nexport class And extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ands\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof And ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.every((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Or extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ors\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof Or ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.some((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Equals extends ComparisonPredicate {\n    // Helpers used to cache dictionary reverse lookups between calls to bind\n    private lastDictionary: Vector|undefined;\n    private lastKey: number|undefined;\n\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v == right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, batch: RecordBatch) => left_func(idx, batch) == right_func(idx, batch);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        if (col.vector instanceof DictionaryVector) {\n            let key: any;\n            const vector = col.vector as DictionaryVector;\n            if (vector.dictionary !== this.lastDictionary) {\n                key = vector.reverseLookup(lit.v);\n                this.lastDictionary = vector.dictionary;\n                this.lastKey = key;\n            } else {\n                key = this.lastKey;\n            }\n\n            if (key === -1) {\n                // the value doesn't exist in the dictionary - always return\n                // false\n                // TODO: special-case of PredicateFunc that encapsulates this\n                // \"always false\" behavior. That way filtering operations don't\n                // have to bother checking\n                return () => false;\n            } else {\n                return (idx: number) => {\n                    return vector.getKey(idx) === key;\n                };\n            }\n        } else {\n            return (idx: number, cols: RecordBatch) => col_func(idx, cols) == lit.v;\n        }\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        // Equals is commutative\n        return this._bindColLit(batch, col, lit);\n    }\n}\n\n/** @ignore */\nexport class LTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v <= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) <= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) <= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v <= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class GTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v >= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) >= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) >= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v >= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class Not extends Predicate {\n    constructor(public readonly child: Predicate) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        const func = this.child.bind(batch);\n        return (idx: number, batch: RecordBatch) => !func(idx, batch);\n    }\n}\n\n/** @ignore */\nexport class CustomPredicate extends Predicate {\n    constructor(private next: PredicateFunc, private bind_: (batch: RecordBatch) => void) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        this.bind_(batch);\n        return this.next;\n    }\n}\n\nexport function lit(v: any): Value<any> { return new Literal(v); }\nexport function col(n: string): Col<any> { return new Col(n); }\nexport function and(...p: Predicate[]): And { return new And(...p); }\nexport function or(...p: Predicate[]): Or { return new Or(...p); }\nexport function custom(next: PredicateFunc, bind: (batch: RecordBatch) => void) {\n    return new CustomPredicate(next, bind);\n}\n"]},"metadata":{},"sourceType":"module"}